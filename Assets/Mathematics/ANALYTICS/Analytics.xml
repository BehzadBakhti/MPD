<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Analytics</name>
    </assembly>
    <members>
        <member name="T:Analytics.Variables.Variable">
            <summary>
            Base abstract class for all Variable types.
            </summary>
        </member>
        <member name="F:Analytics.Variables.Variable.name">
            <summary>
            Name
            </summary>
        </member>
        <member name="M:Analytics.Variables.Variable.GetValueType">
            <summary>
            The Type of Value the variable contains
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.GetValue">
            <summary>
            The Value the variable contains
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.SetValue(System.Object)">
            <summary>
            Sets the Variable Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.Default">
            <summary>
            Default variable value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="M:Analytics.Variables.Variable.TypeToString">
            <summary>
            Value type to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.Variable.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Variables.Variable.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:Analytics.Variables.Variable.ValueType">
            <summary>
            The Type of Value
            </summary>
        </member>
        <member name="P:Analytics.Variables.Variable.Value">
            <summary>
            The Value
            </summary>
        </member>
        <member name="T:Analytics.Variables.ScalarVariable">
            <summary>
            Base abstract class for all scalar variables.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ScalarVariable.data">
            <summary>
            Data value
            </summary>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.GetValue">
            <summary>
            Gets the value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.#ctor(System.String,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.ScalarVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.IndexedVariable">
            <summary>
            Base abstract class for all indexed variables.
            </summary>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetBaseType">
            <summary>
            The Type of elements
            </summary>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetIndexCount">
            <summary>
            Gets index count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetSlicingImplemented">
            <summary>
            Gets index count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.#ctor(System.String,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable Value</param>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetItemValue(System.Int32[])">
            <summary>
            Gets Item value by its index values
            (can implement array slicing)
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.IndexedVariable.GetItemType(System.Int32[])">
            <summary>
            If Array Slicing is implemented
            must be overriden and must return type for sliced item.
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Variables.IndexedVariable.BaseType">
            <summary>
            The Type of Elements
            </summary>
        </member>
        <member name="P:Analytics.Variables.IndexedVariable.IndexCount">
            <summary>
            Index count
            </summary>
        </member>
        <member name="P:Analytics.Variables.IndexedVariable.IsSlicingImplemented">
            <summary>
            Slicing is implemented in GetItemValue
            </summary>
        </member>
        <member name="T:Analytics.Variables.BaseArrayVariable">
            <summary>
            Base abstract class for all indexed variables
            using arrays to store data.
            </summary>
        </member>
        <member name="F:Analytics.Variables.BaseArrayVariable.data">
            <summary>
            Data value
            </summary>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetValue">
            <summary>
            Gets the (Array) value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.SetValue(System.Object)">
            <summary>
            Sets data value (and checks that its type is an array)
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetSlicingImplemented">
            <summary>
            Slicing is NOT implemented for an Array variable by default.
            To implement GetItemValue must be overriden for the variable type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable Value</param>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetItemValue(System.Int32[])">
            <summary>
            Gets item value from array data.
            TODO: implement array slicing
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BaseArrayVariable.GetItemType(System.Int32[])">
            <summary>
            Array Slicing is not implemented for arrays by default
            and this function returns BaseType.
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Variables.BaseArrayVariable.Data">
            <summary>
            Value data
            </summary>
        </member>
        <member name="T:Analytics.Variables.ArrayVariable">
            <summary>
            Base abstract class for all (one dimentional) array variables. 
            </summary>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.SetValue(System.Object)">
            <summary>
            Sets data value and checks its parameters
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.GetIndexCount">
            <summary>
            1 index
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.ArrayVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="P:Analytics.Variables.ArrayVariable.Item(System.Int32)">
            <summary>
            Array element by index
            </summary>
            <param name="index"></param>
            <returns>Matrix element or null if data==null</returns>
        </member>
        <member name="P:Analytics.Variables.ArrayVariable.Length">
            <summary>
            Array Length
            </summary>
        </member>
        <member name="T:Analytics.Variables.MatrixVariable">
            <summary>
            Base abstract class for all matrix variables.
            NOTE: Slicing is implemented.
            </summary>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.SetValue(System.Object)">
            <summary>
            Sets data value and checks its parameters
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetIndexCount">
            <summary>
            2 indexes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetSlicingImplemented">
            <summary>
            Slicing is implemented for Matrix variables
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetItemType(System.Int32[])">
            <summary>
            Sliced item is array of BaseType
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.MatrixVariable.GetItemValue(System.Int32[])">
            <summary>
            Implements Array Slicing
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Variables.MatrixVariable.Item(System.Int32,System.Int32)">
            <summary>
            Matrix element by indexes
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <returns>Array element or null if data==null</returns>
        </member>
        <member name="P:Analytics.Variables.MatrixVariable.RowCount">
            <summary>
            Row count
            </summary>
        </member>
        <member name="P:Analytics.Variables.MatrixVariable.ColumnCount">
            <summary>
            Column count
            </summary>
        </member>
        <member name="T:Analytics.Variables.BlockVariable">
            <summary>
            Base abstract class for all block variables.
            NOTE: slicing is implemented.
            </summary>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.SetValue(System.Object)">
            <summary>
            Sets data value and checks its parameters
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.ValueToString">
            <summary>
            Value to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetIndexCount">
            <summary>
            3 indexes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.#ctor(System.String,System.Array)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetSlicingImplemented">
            <summary>
            Slicing is implemented for Matrix variables
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetItemType(System.Int32[])">
            <summary>
            Sliced item can be matrix or one dimentional array of BaseType.
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BlockVariable.GetItemValue(System.Int32[])">
            <summary>
            Implements Array Slicing
            </summary>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.Item(System.Int32,System.Int32,System.Int32)">
            <summary>
            Block element by indexes
            </summary>
            <param name="row"></param>
            <param name="column"></param>
            <param name="depth"></param>
            <returns>Block element or null if data==null</returns>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.RowCount">
            <summary>
            Row count
            </summary>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.ColumnCount">
            <summary>
            Column count
            </summary>
        </member>
        <member name="P:Analytics.Variables.BlockVariable.DepthCount">
            <summary>
            Depth count
            </summary>
        </member>
        <member name="T:Analytics.ConstantTranslator">
            <summary>
            Special translator class to evaluate CONSTANT expressions only.
            No operation registered by this translator class, so, only 'explicitely' 
            overloaded operators can be used to evaluate constant expressions.
            </summary>
        </member>
        <member name="T:Analytics.Translator">
            <summary>
            Translator.
            Translator is a set of variables and operations
            so it can translate a formula (using syntax rules)
            and calculate it (using current variable values and registered operations).
            NOTE: It contains also a set of named constants realized as a set of static hidden variables. 
                  This set can be used to add nonstandard constants in translator
                  (standard constants Pi, e, ... are recognized now in Parser automatically).
                  The constants can be redefined by adding variables with the same names.
            </summary>
        </member>
        <member name="F:Analytics.Translator.constants">
            <summary>
            (Named) Constants (represented as a set of hidden variables)
            </summary>
        </member>
        <member name="M:Analytics.Translator.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="F:Analytics.Translator.variables">
            <summary>
            Variables
            </summary>
        </member>
        <member name="F:Analytics.Translator.operations">
            <summary>
            Operations
            </summary>
        </member>
        <member name="F:Analytics.Translator.derivatives">
            <summary>
            Derivatives
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateVariables">
            <summary>
            Recreates variables 
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateOperations">
            <summary>
            Recreates Syntax
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateDerivatives">
            <summary>
            Recreates derivative context
            </summary>
        </member>
        <member name="M:Analytics.Translator.RecreateData">
            <summary>
            Recreates obligatory field data
            </summary>
        </member>
        <member name="M:Analytics.Translator.AddVariable(Analytics.Variables.Variable)">
            <summary>
            Just adds a variable into the list.
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Analytics.Translator.EvaluateLiteral(System.String,System.Type@)">
            <summary>
            Evaluates literal to an toolect
            (uses Parser's method).
            </summary>
            <param name="literal"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.VariableExists(System.String)">
            <summary>
            Check if a variable with the name exists
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.Add(Analytics.Variables.Variable)">
            <summary>
            Adds the variable (if no variable with the same name exists)
            </summary>
            <param name="v"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double)">
            <summary>
            Adds standard Real variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double[])">
            <summary>
            Adds standard Real Array variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double[0:,0:])">
            <summary>
            Adds standard Real Matrix variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Add(System.String,System.Double[0:,0:,0:])">
            <summary>
            Adds standard Real Block variable
            </summary>
            <param name="name"></param>
            <param name="value"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Translator.Get(System.String)">
            <summary>
            Gets variable by name
            </summary>
            <param name="name"></param>
            <returns>Variable or null if not found</returns>
        </member>
        <member name="M:Analytics.Translator.Get(System.Int32)">
            <summary>
            Gets variable by index
            </summary>
            <param name="index">Variable or null if index is out of bounds</param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.Delete(System.String)">
            <summary>
            Deletes variable by name
            </summary>
            <param name="name"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Translator.Delete(System.Int32)">
            <summary>
            Deletes variable by index
            </summary>
            <param name="index"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Translator.DeleteAll">
            <summary>
            Deletes all variables
            </summary>
        </member>
        <member name="M:Analytics.Translator.BuildExpressionFormula(Analytics.Syntactic.BaseExpression)">
            <summary>
            Builds the formula by an expression (recursively)
            </summary>
            <param name="exp">Expression (CAN be NULL)</param>
            <returns>Formula, null (or throws an exception)</returns>
        </member>
        <member name="M:Analytics.Translator.BuildExpressionList(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Builds formulae from the expression list.
            </summary>
            <param name="list">List of expressions (can be null or empty).</param>
            <returns>List of formulae.</returns>
        </member>
        <member name="M:Analytics.Translator.BuildFormula(System.String)">
            <summary>
            Builds the formula for a string value.
            NOTE: formula string must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="value">Formula string</param>
            <returns>Formula, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.BuildFormulae(System.String[])">
            <summary>
            Builds the formulae for the string values.
            NOTE: all formula strings must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="values">Formula strings</param>
            <returns>Formula, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.BuildFormulaList(System.Collections.Generic.List{System.String})">
            <summary>
            Builds the formulae for the string values.
            NOTE: all formula strings must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="values">Formula strings</param>
            <returns>Formula, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.Calculate(System.String)">
            <summary>
            Calculates formula value for current variable values.
            NOTE: formula string must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="value">Formula string</param>
            <returns>Calculated toolect, or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.Calculate(Analytics.Syntactic.BaseExpression)">
            <summary>
            Calculates expression value for current variable values.
            </summary>
            <param name="expr">Expression</param>
            <returns>Calculated toolect, or throws an exception</returns>
        </member>
        <member name="M:Analytics.Translator.CheckSyntax(System.String)">
            <summary>
            Checks string syntax correctness.
            </summary>
            <param name="value">A string to check</param>
            <returns>True, if correct, throws a syntax exception if not correct.</returns>
        </member>
        <member name="M:Analytics.Translator.Simplify(System.String)">
            <summary>
            Simplifies string expression.
            NOTE: formula string must be syntactically correct
                  (function does not check the syntax).
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.Evaluate(System.Collections.Generic.List{Analytics.Variables.Variable},Analytics.Syntactic.BaseExpression@)">
            <summary>
            Partially evaluates expression by substituting current variable values
            from provided variable list.
            WARNING: for REAL variables only.
            </summary>
            <param name="values"></param>
            <param name="expr"></param>
            <returns>True, if any substitution made.</returns>
        </member>
        <member name="M:Analytics.Translator.Evaluate(System.Collections.Generic.List{Analytics.Variables.Variable},System.String)">
            <summary>
            Partially evaluates string formula by substituting current variable values
            from provided variable list.
            WARNING: for REAL variables only.
            </summary>
            <param name="values"></param>
            <param name="value"></param>
            <returns>Evaluated value (or initial value if no substitution made)</returns>
        </member>
        <member name="M:Analytics.Translator.CalculateDerivative(Analytics.Syntactic.BaseExpression,System.String)">
            <summary>
            Calculates expression derivative
            (and simlifies result expression).
            </summary>
            <param name="expr"></param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Translator.Derivative(System.String,System.String)">
            <summary>
            Calculates derivative of the formula.
            </summary>
            <param name="formula">Formula</param>
            <param name="vName">Variable name.</param>
            <returns>Simplified result formula.</returns>
        </member>
        <member name="M:Analytics.Translator.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.Translator.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Translator.Operations">
            <summary>
            Current operation set
            </summary>
        </member>
        <member name="P:Analytics.Translator.VariableCount">
            <summary>
            Variable count
            </summary>
        </member>
        <member name="P:Analytics.Translator.Variables">
            <summary>
            Variable Set
            </summary>
        </member>
        <member name="P:Analytics.Translator.Derivatives">
            <summary>
            Derivative context
            </summary>
        </member>
        <member name="M:Analytics.ConstantTranslator.RecreateOperations">
            <summary>
            Just creates empty operation set.
            </summary>
        </member>
        <member name="M:Analytics.ConstantTranslator.RecreateVariables">
            <summary>
            Variable == null, do not use.
            </summary>
        </member>
        <member name="M:Analytics.ConstantTranslator.RecreateDerivatives">
            <summary>
            Derivatives == null, do not use.
            </summary>
        </member>
        <member name="P:Analytics.ConstantTranslator.ConstantEvaluator">
            <summary>
            Static instance for constant expression evaluation.
            </summary>
        </member>
        <member name="T:Analytics.Utilities">
            <summary>
            Utility class
            </summary>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorSign(Analytics.OperatorType)">
            <summary>
            Operator Sign
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorType(System.String,Analytics.OperatorArity)">
            <summary>
            Gets operator type by its sign and arity.
            </summary>
            <param name="sign"></param>
            <param name="arity"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorPrecedence(Analytics.OperatorType)">
            <summary>
            Operator Precedence
            (operators with higher precedence applied before operators with lower precedence)
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorArity(Analytics.OperatorType)">
            <summary>
            Operator arity
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetOperatorPosition(Analytics.OperatorType)">
            <summary>
            Operator position
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetBinaryOperationType(Analytics.OperatorType)">
            <summary>
            Returns binary operation type for the operator type
            or throws an EXCEPTION if the type is not defined.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetBinaryOperationType(System.String)">
            <summary>
            Returns binary operation type for the operator type
            or throws an EXCEPTION if the type is not defined.
            </summary>
            <param name="sign"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.OperatorCount">
            <summary>
            Defined Operator Count (excluding Undefined value)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.IsDerivativeDefined(Analytics.OperatorType)">
            <summary>
            Checks, if derivative is defined for the operator type.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetOverloadedOperatorName(Analytics.OperatorType)">
            <summary>
            Gets run-time method name for overloaded operator analogue.
            </summary>
            <param name="t"></param>
            <returns>Method name if analogue exists, null if not.</returns>
        </member>
        <member name="M:Analytics.Utilities.GetExplicitUnaryOperator(Analytics.OperatorType,System.Type)">
            <summary>
            Gets overloaded operator method from the type
            that corresponds to the unary operator type.
            </summary>
            <param name="t"></param>
            <param name="operandType"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetExplicitBinaryOperator(Analytics.OperatorType,System.Type,System.Type)">
            <summary>
            Gets overloaded operator method from the type
            that corresponds to the binary operator type.
            </summary>
            <param name="t"></param>
            <param name="operand1Type"></param>
            <param name="operand2Type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.SafeToString(System.Object)">
            <summary>
            Safe call ToString (for null toolect returns null symbol)
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetTypeName(System.Type)">
            <summary>
            Safety gets type name
            </summary>
            <param name="t">Type (can be null)</param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.GetTypeNames(System.Type[])">
            <summary>
            Gets type names (safety)
            </summary>
            <param name="types"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.SafeArrayLength(System.Array)">
            <summary>
            Safely gets the Length of the FIRST array dimension
            (for null value returns 0)
            </summary>
            <param name="x"></param>
            <returns>Length of the FIRST array dimension</returns>
        </member>
        <member name="M:Analytics.Utilities.TypeEquals(System.Type,System.Type)">
            <summary>
            Compares Types
            </summary>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.TypeCompatible(System.Type,System.Type)">
            <summary>
            Checks if the second type can be used instead of the first
            </summary>
            <param name="expected"></param>
            <param name="actual"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.TypesEqual(System.Type[],System.Type[])">
            <summary>
            Compares Type Arrays
            </summary>
            <param name="t1"></param>
            <param name="t2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.TypesEqual(System.Type[],System.Type[],System.Type@,System.Type@)">
            <summary>
            Compares Type Arrays and returns two types that are not equal.
            </summary>
            <param name="t1"></param>
            <param name="t2"></param>
            <param name="l"></param>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.TypesCompatible(System.Type[],System.Type[])">
            <summary>
            Checks Type Arrays compatibility (the second can be used instead of the first) 
            </summary>
            <param name="expected"></param>
            <param name="actual"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.TypesCompatible(System.Type[],System.Type[],System.Type@,System.Type@)">
            <summary>
            Checks Type Arrays compatibility (the second can be used instead of the first) 
            and returns two types that are not compatible.
            </summary>
            <param name="expected"></param>
            <param name="actual"></param>
            <param name="l"></param>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Utilities.CheckNonnegativeArgument(System.Double,System.String)">
            <summary>
            Checks if the value is nonnegative.
            If not - throws exception.
            </summary>
            <param name="value"></param>
            <param name="operation"></param>
        </member>
        <member name="M:Analytics.Utilities.CheckIntegerArgument(System.Double,System.String)">
            <summary>
            Checks if the value is "integer".
            If not - throws exception.
            </summary>
            <param name="value"></param>
            <param name="operation"></param>
        </member>
        <member name="T:Analytics.SyntaxError">
            <summary>
            Syntax Error base class
            </summary>
        </member>
        <member name="M:Analytics.SyntaxError.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
        </member>
        <member name="P:Analytics.SyntaxError.Description">
            <summary>
            Error Description
            </summary>
        </member>
        <member name="P:Analytics.SyntaxError.Primary">
            <summary>
            Primary string
            </summary>
        </member>
        <member name="P:Analytics.SyntaxError.Position1">
            <summary>
            First position
            </summary>
        </member>
        <member name="P:Analytics.SyntaxError.Position2">
            <summary>
            Second position
            </summary>
        </member>
        <member name="T:Analytics.ParanthesisError">
            <summary>
            Paranthesis Error base class
            </summary>
        </member>
        <member name="M:Analytics.ParanthesisError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="p"></param>
        </member>
        <member name="T:Analytics.UnexpectedParanthesis">
            <summary>
            Unexpected (closing) paranthesis error.
            </summary>
        </member>
        <member name="M:Analytics.UnexpectedParanthesis.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="p"></param>
        </member>
        <member name="T:Analytics.ParanthesisExpected">
            <summary>
            Paranthesis (closing) expected.
            </summary>
        </member>
        <member name="M:Analytics.ParanthesisExpected.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="p"></param>
        </member>
        <member name="T:Analytics.ParanthesisExpectedButFound">
            <summary>
            Paranthesis (closing) expected but another found.
            </summary>
        </member>
        <member name="M:Analytics.ParanthesisExpectedButFound.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="p"></param>
        </member>
        <member name="T:Analytics.SymbolParityError">
            <summary>
            Symbol Parity Error base class
            </summary>
        </member>
        <member name="M:Analytics.SymbolParityError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="p"></param>
        </member>
        <member name="T:Analytics.ParanthesisMustBeClosedError">
            <summary>
            Paranthesis not closed befor parity symbol.
            </summary>
        </member>
        <member name="M:Analytics.ParanthesisMustBeClosedError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="p"></param>
        </member>
        <member name="T:Analytics.ClosingSymbolParityError">
            <summary>
            Closing Symbol parity error.
            </summary>
        </member>
        <member name="M:Analytics.ClosingSymbolParityError.#ctor(System.String,System.Int32,System.Int32,Analytics.Syntactic.SymbolPair)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="p"></param>
        </member>
        <member name="T:Analytics.InvalidConstructionError">
            <summary>
            Invalid Construction base class
            </summary>
        </member>
        <member name="M:Analytics.InvalidConstructionError.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="pos2"></param>
            <param name="s"></param>
        </member>
        <member name="T:Analytics.InvalidSymbolError">
            <summary>
            Invalid Symbol base class
            </summary>
        </member>
        <member name="M:Analytics.InvalidSymbolError.#ctor(System.String,System.Int32,System.Char)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="s"></param>
        </member>
        <member name="T:Analytics.InvalidBeginSymbolError">
            <summary>
            Invalid Begin Symbol
            </summary>
        </member>
        <member name="M:Analytics.InvalidBeginSymbolError.#ctor(System.String,System.Int32,System.Char)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="s"></param>
        </member>
        <member name="T:Analytics.InvalidEndSymbolError">
            <summary>
            Invalid End Symbol
            </summary>
        </member>
        <member name="M:Analytics.InvalidEndSymbolError.#ctor(System.String,System.Int32,System.Char)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
            <param name="pos1"></param>
            <param name="s"></param>
        </member>
        <member name="T:Analytics.SyntaxRuleFunction">
            <summary>
            Syntax Rule delegate
            </summary>
            <param name="value"></param>
            <param name="error"></param>
            <returns>True, if the rule is fulfilled</returns>
        </member>
        <member name="T:Analytics.SyntaxRule">
            <summary>
            Syntax rule class.
            Contains syntax rule function and its characteristics.
            </summary>
        </member>
        <member name="P:Analytics.SyntaxRule.RuleFunction">
            <summary>
            Function
            </summary>
        </member>
        <member name="T:Analytics.Syntax">
            <summary>
            Static class to check syntax rules.
            Only to chek rules those have no need to decompose string value into expression sequence.
            For an example - parantheses compatibility, bad symbol sequence (*/, -*) and so on.
            Other errors (such as unknown functions and variables, wrong function argument count and so on)
            can be detected by Expression Build and Translator Build functions.
            </summary>
        </member>
        <member name="F:Analytics.Syntax.rules">
            <summary>
            Registered rules.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.PairsRule(System.String,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Int32@,Analytics.Syntactic.SymbolPair@)">
            <summary>
            Checks pair compatibility rule.
            There can be three cases of incompatibility:
            1. There is a closer and no opener - sin(x)*y).
            2. Some pairs are confused - sin(A[i)].
            3. There is an opener but no closer sin(2*A[1].
            </summary>
            <param name="value"></param>
            <param name="pairs"></param>
            <param name="errorindex"></param>
            <param name="errorpair"></param>
            <returns> 0 for no errors
                     -1 for error 1
                     -2 for error 2
                     +n for error 3</returns>
        </member>
        <member name="M:Analytics.Syntax.ParanthesesRule(System.String,Analytics.SyntaxError@)">
            <summary>
            Parantheses compatibility rule.
            </summary>
            <param name="value"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntax.SymbolParityRule(System.String,System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Int32@,Analytics.Syntactic.SymbolPair@)">
            <summary>
            Checks parity rule for one char.
            The char is opening and closing symbol.
            If char is opened, all pairs must be closed, before the char is closed.
            (the function does not check pairs for rules)
            </summary>
            <param name="value"></param>
            <param name="parity"></param>
            <param name="pairs"></param>
            <param name="errorindex"></param>
            <param name="errorpair"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntax.ParitiesRule(System.String,Analytics.SyntaxError@)">
            <summary>
            Parities rule.
            </summary>
            <param name="value"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntax.PairsNotAllowedRule(System.String,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Int32@,Analytics.Syntactic.SymbolPair@)">
            <summary>
            Finds not allowed pairs of symbols.
            </summary>
            <param name="value"></param>
            <param name="pairs"></param>
            <param name="errorindex"></param>
            <param name="errorpair"></param>
            <returns> 0 for no errors
                     -1 if error pair found</returns>
        </member>
        <member name="M:Analytics.Syntax.InvalidConstructionRule(System.String,Analytics.SyntaxError@)">
            <summary>
            Invalid construction rule.
            </summary>
            <param name="value"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntax.BeginSymbolError(System.String,System.Collections.Generic.List{System.Char},System.Char@)">
            <summary>
            Begin symbol error
            </summary>
            <param name="value"></param>
            <param name="symbols"></param>
            <param name="error"></param>
            <returns>TRUE, IF ERROR</returns>
        </member>
        <member name="M:Analytics.Syntax.EndSymbolError(System.String,System.Collections.Generic.List{System.Char},System.Char@)">
            <summary>
            End symbol error
            </summary>
            <param name="value"></param>
            <param name="symbols"></param>
            <param name="error"></param>
            <returns>TRUE, IF ERROR</returns>
        </member>
        <member name="M:Analytics.Syntax.ErrorSymbolRule(System.String,Analytics.SyntaxError@)">
            <summary>
            Error Symbol rule.
            </summary>
            <param name="value"></param>
            <param name="error"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntax.#cctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Analytics.Syntax.Check(System.String)">
            <summary>
            Checks string syntax correctness.
            </summary>
            <param name="value">A string to check</param>
            <returns>True, if correct, throws a syntax exception if not correct.</returns>
        </member>
        <member name="T:Analytics.Messages">
            <summary>
            Messages
            (fields are public and not readonly and so can be localized).
            </summary>
        </member>
        <member name="T:Analytics.Expression">
            <summary>
            String Expression structure.
            Contains one string field and connected with it expression toolect.
            Overloads operators to manipulate with strings as expressions (multiply, negate and so on).
            All algorithms decompose strings into Syntactic Expression toolects, then make operations with them, 
            simplify the result and finally reconstruct the result back to string.
            NOTE: an expression cannot be changed during lifetime and is simplified on creation.
            NOTE: only Explicit conversion from/to string is provided, because implicit one
                  can cause problems (then it could be written Expression*string, Expression+string and so on,
                  and this could make IMPLICIT effects).
            WARNING: all manipulated strings MUST be syntactically correct,
                     no check done inside the structure, exceptions can be thrown.
            </summary>
        </member>
        <member name="M:Analytics.Expression.#ctor(System.String)">
            <summary>
            Creates Expression from string value.
            Used in implicit conversion.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Expression.#ctor(Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates Expression structure by BaseExpression toolect.
            Used in overloaded operators to return result values.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Expression.op_Explicit(Analytics.Expression)~System.String">
            <summary>
            Explicit conversion to string.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Explicit(System.String)~Analytics.Expression">
            <summary>
            Explicit conversion from string
            (the only way Expression structures must be created).
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_UnaryNegation(Analytics.Expression)">
            <summary>
            Unary minus operator.
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Addition(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary + operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Subtraction(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary - operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Multiply(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary * operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_Division(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary / operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.op_ExclusiveOr(Analytics.Expression,Analytics.Expression)">
            <summary>
            Binary ^ (power) operator.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.Sqr(Analytics.Expression)">
            <summary>
            Square
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.Sqrt(Analytics.Expression)">
            <summary>
            Square Root
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsZero">
            <summary>
            Is Zero
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsUnit">
            <summary>
            Is Unit
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsInfinity">
            <summary>
            Is Infinity
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Expression.IsNaN">
            <summary>
            Is NaN
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.AnalyticsException">
            <summary>
            Base abstract class for all Analytics exceptions
            (to recognize simply the library specific exceptions)
            </summary>
        </member>
        <member name="M:Analytics.AnalyticsException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message"></param>
        </member>
        <member name="T:Analytics.WrongArgumentException">
            <summary>
            Argument Exception - got toolect is not what is expected
            </summary>
        </member>
        <member name="M:Analytics.WrongArgumentException.#ctor(System.String,System.Object,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="message"></param>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.NULLArgumentException">
            <summary>
            NULL Argument Exception
            </summary>
        </member>
        <member name="T:Analytics.OperationNotApplicableException">
            <summary>
            Operation not applicable for some data
            </summary>
        </member>
        <member name="M:Analytics.OperationNotApplicableException.#ctor(System.Object,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="operation"></param>
            <param name="data"></param>
        </member>
        <member name="T:Analytics.IntegerValueException">
            <summary>
            Error of value - it must be integer
            </summary>
        </member>
        <member name="M:Analytics.IntegerValueException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.NonnegativeValueException">
            <summary>
            Error of value - it must be nonnegative
            </summary>
        </member>
        <member name="M:Analytics.NonnegativeValueException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.InvalidNameException">
            <summary>
            Invalid Name Exception
            </summary>
        </member>
        <member name="T:Analytics.VariableValueTypeException">
            <summary>
            Error of Variable value type.
            </summary>
        </member>
        <member name="M:Analytics.VariableValueTypeException.#ctor(System.Type,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.IndexCountException">
            <summary>
            Error of index count
            </summary>
        </member>
        <member name="M:Analytics.IndexCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.IndexTypeException">
            <summary>
            Error of index type
            </summary>
        </member>
        <member name="M:Analytics.IndexTypeException.#ctor(System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.IndexValueException">
            <summary>
            Error of index value
            </summary>
        </member>
        <member name="M:Analytics.IndexValueException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Analytics.ParameterCountException">
            <summary>
            Error of parameter count
            </summary>
        </member>
        <member name="M:Analytics.ParameterCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.ParameterTypeException">
            <summary>
            Error of Parameter type
            </summary>
        </member>
        <member name="M:Analytics.ParameterTypeException.#ctor(System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.ArgumentCountException">
            <summary>
            Error of Argument count
            </summary>
        </member>
        <member name="M:Analytics.ArgumentCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.ArgumentTypeException">
            <summary>
            Error of Argument type
            </summary>
        </member>
        <member name="M:Analytics.ArgumentTypeException.#ctor(System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.OperandCountException">
            <summary>
            Error of Operand Count
            </summary>
        </member>
        <member name="M:Analytics.OperandCountException.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="expected"></param>
            <param name="got"></param>
        </member>
        <member name="T:Analytics.UnknownLiteralException">
            <summary>
            Error of Literal Value
            </summary>
        </member>
        <member name="M:Analytics.UnknownLiteralException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Analytics.UnknownExpressionException">
            <summary>
            Error of Literal Value
            </summary>
        </member>
        <member name="M:Analytics.UnknownExpressionException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Analytics.UnsupportedExpressionTypeException">
            <summary>
            Unsupported expression type
            </summary>
        </member>
        <member name="M:Analytics.UnsupportedExpressionTypeException.#ctor(System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="t">Type of expression</param>
        </member>
        <member name="M:Analytics.UnsupportedExpressionTypeException.#ctor(System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="t">Type of expression</param>
        </member>
        <member name="T:Analytics.VariableNotFoundException">
            <summary>
            Variable not found
            </summary>
        </member>
        <member name="M:Analytics.VariableNotFoundException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:Analytics.UnknownOperatorException">
            <summary>
            Unknown operator
            </summary>
        </member>
        <member name="M:Analytics.UnknownOperatorException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="sign"></param>
        </member>
        <member name="T:Analytics.UnaryOperatorNotFoundException">
            <summary>
            Unary operator not found
            </summary>
        </member>
        <member name="M:Analytics.UnaryOperatorNotFoundException.#ctor(System.String,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="sign">Operator sign</param>
            <param name="opnd">Operand type</param>
        </member>
        <member name="T:Analytics.BinaryOperatorNotFoundException">
            <summary>
            Binary operator not found
            </summary>
        </member>
        <member name="M:Analytics.BinaryOperatorNotFoundException.#ctor(System.String,System.Type,System.Type)">
            <summary>
            Constructor
            </summary>
            <param name="sign">Operator sign</param>
            <param name="opnd1">1st Operand type</param>
            <param name="opnd2">2nd Operand type</param>
        </member>
        <member name="T:Analytics.FunctionNotFoundException">
            <summary>
            Function not found
            </summary>
        </member>
        <member name="M:Analytics.FunctionNotFoundException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="signature">Function signature</param>
        </member>
        <member name="T:Analytics.SlicingNotImplementedException">
            <summary>
            Slicing not implemented
            </summary>
        </member>
        <member name="M:Analytics.SlicingNotImplementedException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name">Function signature</param>
        </member>
        <member name="T:Analytics.SyntaxException">
            <summary>
            Base class for Syntax Error exceptions
            </summary>
        </member>
        <member name="F:Analytics.SyntaxException.error">
            <summary>
            Syntax error cosed the exception
            </summary>
        </member>
        <member name="M:Analytics.SyntaxException.#ctor(Analytics.SyntaxError)">
            <summary>
            Constructor
            </summary>
            <param name="e"></param>
        </member>
        <member name="P:Analytics.SyntaxException.Error">
            <summary>
            The Syntax error caused the exception.
            </summary>
        </member>
        <member name="T:Analytics.DerivativeException">
            <summary>
            Base class for derivative exceptions
            </summary>
        </member>
        <member name="T:Analytics.OperatorDerivativeException">
            <summary>
            Derivative not defined for operator exception
            </summary>
        </member>
        <member name="T:Analytics.OperationsDerivativeException">
            <summary>
            Derivative not defined for operations sequence exception
            </summary>
        </member>
        <member name="T:Analytics.FunctionDerivativeException">
            <summary>
            Derivative not defined for function exception
            </summary>
        </member>
        <member name="M:Analytics.FunctionDerivativeException.Create(System.String,System.Int32,System.Int32)">
            <summary>
            Creates the exception by parameters
            </summary>
            <param name="func"></param>
            <param name="pcount"></param>
            <param name="acount"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.FunctionDerivativeParameterException">
            <summary>
            Function parameters must not depend on variable for Derivative exception
            </summary>
        </member>
        <member name="T:Analytics.Variables.VariableSet">
            <summary>
            The set of variables
            </summary>
        </member>
        <member name="F:Analytics.Variables.VariableSet.data">
            <summary>
            Variables
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.RecreateData">
            <summary>
            Recreates variables 
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.AddVariable(Analytics.Variables.Variable)">
            <summary>
            Safely adds variable to the list
            </summary>
            <param name="v"></param>
        </member>
        <member name="M:Analytics.Variables.VariableSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.Variables.VariableSet.VariableExists(System.String)">
            <summary>
            Finds the variable number by name
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Add(Analytics.Variables.Variable)">
            <summary>
            Adds the variable (if no variable with the same name exists
            and if variable is not null)
            </summary>
            <param name="v"></param>
            <returns>True, if added</returns>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Delete(System.String)">
            <summary>
            Deletes variable by name
            </summary>
            <param name="name"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Delete(System.Int32)">
            <summary>
            Deletes variable by index
            </summary>
            <param name="index"></param>
            <returns>True if deleted</returns>
        </member>
        <member name="M:Analytics.Variables.VariableSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Variables.VariableSet.VariableCount">
            <summary>
            Variable count
            </summary>
        </member>
        <member name="P:Analytics.Variables.VariableSet.Item(System.String)">
            <summary>
            Indexing by Variable Name
            </summary>
            <param name="index">Variable name</param>
            <returns>Variable or null if not found</returns>
        </member>
        <member name="P:Analytics.Variables.VariableSet.Item(System.Int32)">
            <summary>
            Indexing by Variable index
            </summary>
            <param name="index">Variable index</param>
            <returns>Variable or null if index is out of range</returns>
        </member>
        <member name="P:Analytics.Variables.VariableSet.Data">
            <summary>
            Variable List
            </summary>
        </member>
        <member name="T:Analytics.Symbols">
            <summary>
            Symbols used in expressions
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NotOperator">
            <summary>
            Not
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AndOperator">
            <summary>
            And
            </summary>
        </member>
        <member name="F:Analytics.Symbols.OrOperator">
            <summary>
            Or
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IdenticallyOperator">
            <summary>
            Exact equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ApproximatelyOperator">
            <summary>
            Approximately equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NotequalOperator">
            <summary>
            Not Equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.GreaterOperator">
            <summary>
            Greater 
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LessOperator">
            <summary>
            Less
            </summary>
        </member>
        <member name="F:Analytics.Symbols.GreaterorequalOperator">
            <summary>
            Greater or Equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LessorequalOperator">
            <summary>
            Less or Equal
            </summary>
        </member>
        <member name="F:Analytics.Symbols.MinusOperator">
            <summary>
            Unary Minus
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AddOperator">
            <summary>
            Binary Add
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SubtractOperator">
            <summary>
            Binary subtract
            </summary>
        </member>
        <member name="F:Analytics.Symbols.MultiplyOperator">
            <summary>
            Multiply
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DivideOperator">
            <summary>
            Divide
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PowerOperator">
            <summary>
            Power
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FactorialOperator">
            <summary>
            Factorial
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ApostropheOperator">
            <summary>
            Apostrophe
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DotOperator">
            <summary>
            Dot product
            </summary>
        </member>
        <member name="F:Analytics.Symbols.TildeOperator">
            <summary>
            Tilde
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SquareRootOperator">
            <summary>
            Square Root
            </summary>
        </member>
        <member name="F:Analytics.Symbols.QuestionOperator">
            <summary>
            Question
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NumberOperator">
            <summary>
            Number
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DerivativeOperator">
            <summary>
            Derivative
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IntegralOperator">
            <summary>
            Integral
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DeltaOperator">
            <summary>
            Delta
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SumOperator">
            <summary>
            Summ
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ProductOperator">
            <summary>
            Product
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftarrowOperator">
            <summary>
            Left arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightarrowOperator">
            <summary>
            Right arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UparrowOperator">
            <summary>
            Up arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.DownarrowOperator">
            <summary>
            Down arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftrightarrowOperator">
            <summary>
            Left-Right arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UpdownarrowOperator">
            <summary>
            Up-Down arrow
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AssignementOperator">
            <summary>
            Assignement
            TODO: not realized
            </summary>
        </member>
        <member name="F:Analytics.Symbols.AbsoluteOperator">
            <summary>
            Absolute
            TODO: not totally realized
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ArgumentSeparator">
            <summary>
            Argument separator
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ImaginarySymbol">
            <summary>
            Imaginary symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UnitSymbol">
            <summary>
            Unit symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ZeroSymbol">
            <summary>
            Zero symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ImaginaryString">
            <summary>
            Imaginary string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UnitString">
            <summary>
            Unit string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ZeroString">
            <summary>
            Zero string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinitySymbol">
            <summary>
            Infinity symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinityName">
            <summary>
            Infinity string (short)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinityFullName">
            <summary>
            Infinity string (full)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NaNName">
            <summary>
            NaN string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.InfinityString">
            <summary>
            Infinity string (symbol)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PiSymbol">
            <summary>
            Pi symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PiName">
            <summary>
            Pi string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.EulerSymbol">
            <summary>
            e symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.PiString">
            <summary>
            Pi string (symbol)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.EulerString">
            <summary>
            e string (symbol)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.TrueName">
            <summary>
            True constant
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FalseName">
            <summary>
            False constant
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UniversalZeroSymbol">
            <summary>
            Universal zero symbol
            TODO: not realized (how to use?)
            </summary>
        </member>
        <member name="F:Analytics.Symbols.UniversalZeroString">
            <summary>
            Universal zero string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NaturalLogarithm">
            <summary>
            This static field is introduced to define natural logarithm function,
            because this function has special meaning and the same name must be
            used everywere it assumed (for an example - in power derivative).
            </summary>
        </member>
        <member name="F:Analytics.Symbols.Exponent">
            <summary>
            Exponent function name
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FunctionLeftBracket">
            <summary>
            Function left
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FunctionRightBracket">
            <summary>
            Function right
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IndexLeftBracket">
            <summary>
            Index left
            </summary>
        </member>
        <member name="F:Analytics.Symbols.IndexRightBracket">
            <summary>
            Index right
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ParameterLeftBracket">
            <summary>
            Parameter left
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ParameterRightBracket">
            <summary>
            Parameter right
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftDoublequotation">
            <summary>
            Left double quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightDoublequotation">
            <summary>
            Right double quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftQuotation">
            <summary>
            Left quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightQuotation">
            <summary>
            Right quotation
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftTrianglebracket">
            <summary>
            Left triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightTrianglebracket">
            <summary>
            Right triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.LeftDoubletrianglebracket">
            <summary>
            Left double triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.RightDoubletrianglebracket">
            <summary>
            Right double triangle
            </summary>
        </member>
        <member name="F:Analytics.Symbols.FunctionSign">
            <summary>
            Function operator sign
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NullValue">
            <summary>
            Null string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.ReplacerSign">
            <summary>
            Replace symbol
            </summary>
        </member>
        <member name="F:Analytics.Symbols.NotDefinedSign">
            <summary>
            Not defined string
            </summary>
        </member>
        <member name="F:Analytics.Symbols.GreekLetterrs">
            <summary>
            Greek letters
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SubscriptDigits">
            <summary>
            Subscript digits
            </summary>
        </member>
        <member name="F:Analytics.Symbols.SuperscriptDigits">
            <summary>
            Superscript digits
            </summary>
        </member>
        <member name="T:Analytics.NETRuntimeSymbols">
            <summary>
            NET Run-Time Symbols
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.OperatorPrefix">
            <summary>
            NET run-time operator prefix
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.AdditionName">
            <summary>
            + name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.SubtractionName">
            <summary>
            - (binary) name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.MultiplyName">
            <summary>
            * name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.DivisionName">
            <summary>
            / name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.NegationName">
            <summary>
            - (unary) name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.EqualityName">
            <summary>
            = name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.InequalityName">
            <summary>
            != name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.LessName">
            <summary>
            less name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.GreaterName">
            <summary>
            greater name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.LessorequalName">
            <summary>
            less or equal name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.GreaterorequalName">
            <summary>
            greater or equal
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.NotName">
            <summary>
            not name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.AndName">
            <summary>
            and name
            </summary>
        </member>
        <member name="F:Analytics.NETRuntimeSymbols.OrName">
            <summary>
            or name
            </summary>
        </member>
        <member name="T:Analytics.Functions.Function">
            <summary>
            Abstract base class for any function.
            A Function has Name, number of arguments, argument types,
            number of parameters, parameter types and the Result type.
            NOTE (about parameters): parameter is an additional value that determines a function.
            For an example, the logarithm of 'x' to the base 'a' is a function
            of argument 'x' and with one parameter 'a'. Generally a parameter can
            be considered as a variable (or can depend on variables) but THIS
            library distinguishes ARGUMENTS and PARAMETERS.
            http://en.wikipedia.org/wiki/List_of_mathematical_functions
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.parameterTypes">
            <summary>
            Parameter types
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.argumentTypes">
            <summary>
            Argument types
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.resultType">
            <summary>
            Function result type
            </summary>
        </member>
        <member name="F:Analytics.Functions.Function.parameterValues">
            <summary>
            Current Values of Function Parameters
            </summary>
        </member>
        <member name="M:Analytics.Functions.Function.GetName">
            <summary>
            The function name
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetArgumentCount">
            <summary>
            The function argument count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetArgumentTypes">
            <summary>
            Get Argument types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetParameterCount">
            <summary>
            The function parameter count
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetParameterTypes">
            <summary>
            Get Parameter types
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.GetResultType">
            <summary>
            Get Result Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.DoCalculate(System.Object[],System.Object[])">
            <summary>
            Result calculation
            </summary>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Functions.Function.Calculate(System.Object[],System.Object[])">
            <summary>
            Result calculation
            </summary>
            <param name="parameters">Parameter values</param>
            <param name="arguments">Argument values</param>
            <returns>Calculation Result</returns>
        </member>
        <member name="M:Analytics.Functions.Function.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Functions.Function.ToTemplate(System.String)">
            <summary>
            Function template
            </summary>
            <param name="replacer"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Functions.Function.Name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ParameterCount">
            <summary>
            Parameter count
            (if negative - any parameter count aceptable)
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ParameterTypes">
            <summary>
            Parameter types
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ArgumentCount">
            <summary>
            Argument count
            (if negative - any argument count aceptable)
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ArgumentTypes">
            <summary>
            Argument types
            </summary>
        </member>
        <member name="P:Analytics.Functions.Function.ResultType">
            <summary>
            Function Result Type
            </summary>
        </member>
        <member name="T:Analytics.Functions.MonotypeFunction">
            <summary>
            Monotype function is a function that has all
            parameters and arguments of ONE type (not Mathematical concept,
            usefull only as programming class).
            The type is based on GetResultType.
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseRealElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions of DOUBLE ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseComplexElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions of COMPLEX ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.RealElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE DOUBLE argument and ZERO parameters (sin, ln, exp and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealElementaryFunction.Func(System.Double)">
            <summary>
            The calculation function of ONE DOUBLE arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.RealParametricElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE DOUBLE argument and ONE DOUBLE parameter (logarithm of x to base y).
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealParametricElementaryFunction.Func(System.Double,System.Double)">
            <summary>
            The calculation function of ONE DOUBLE parameter and ONE DOUBLE arqument
            </summary>
            <param name="parameter"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE COMPLEX argument and ZERO parameters (sin, ln, exp and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexElementaryFunction.Func(System.Numerics.Complex)">
            <summary>
            The calculation function of ONE COMPLEX arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexParametricElementaryFunction">
            <summary>
            Base abstract class for all ELEMENTARY functions
            of ONE COMPLEX argument and ONE COMPLEX parameter (logarithm of x to base y).
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexParametricElementaryFunction.Func(System.Numerics.Complex,System.Numerics.Complex)">
            <summary>
            The calculation function of ONE COMPLEX parameter and ONE COMPLEX arqument
            </summary>
            <param name="parameter"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.BaseSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseRealSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions of DOUBLE ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.BaseComplexSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions of COMPLEX ARGUMENTS
            </summary>
        </member>
        <member name="T:Analytics.Functions.RealSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions
            of ONE DOUBLE argument and ZERO parameters (abs, sgn and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealSpecialFunction.Func(System.Double)">
            <summary>
            The calculation function of ONE DOUBLE arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexSpecialFunction">
            <summary>
            Base abstract class for all SPECIAL functions
            of ONE COMPLEX argument and ZERO parameters (abs, sgn and so on).
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexSpecialFunction.Func(System.Numerics.Complex)">
            <summary>
            The calculation function of ONE COMPLEX arqument
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexRealFunction">
            <summary>
            Base Abstract class for functions of ONE Complex argument
            those return DOUBLE values.
            NOTE: This class is out of main function class hierarchy
                  and used to simplify programming.
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexRealFunction.Func(System.Numerics.Complex)">
            <summary>
            Calculation function
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.ComplexRealParametricFunction">
            <summary>
            Base Abstract class for functions of ONE Complex parameter  
            and ONE Real argument those return COMPLEX values.
            NOTE: This class is out of main function class hierarchy
                  and used to simplify programming.
            </summary>
        </member>
        <member name="M:Analytics.Functions.ComplexRealParametricFunction.Func(System.Numerics.Complex,System.Double)">
            <summary>
            Calculation function
            </summary>
            <param name="par"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.RealComplexParametricFunction">
            <summary>
            Base Abstract class for functions of ONE Real parameter  
            and ONE Complex argument those return COMPLEX values.
            NOTE: This class is out of main function class hierarchy
                  and used to simplify programming.
            </summary>
        </member>
        <member name="M:Analytics.Functions.RealComplexParametricFunction.Func(System.Double,System.Numerics.Complex)">
            <summary>
            Calculation function
            </summary>
            <param name="par"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.BaseGenericFunction`1">
            <summary>
            Base abstract class for all Generic Functions.
            Introduces result type (because all functions have it).
            The inherited Generic functions introduce the number and the types
            of parameters and arguments simplifying implementation of final
            function types to only providing the name and the calculation algorithm.
            </summary>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="T:Analytics.Functions.GenericSimpleFunction`2">
            <summary>
            Generic Abstract class for functions with ONE argument (and ZERO parameters).
            </summary>
            <typeparam name="ArgumentType"></typeparam>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="M:Analytics.Functions.GenericSimpleFunction`2.Func(`0)">
            <summary>
            The calculation Function.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBinaryFunction`3">
            <summary>
            Generic Abstract class for functions with TWO arguments (and ZERO parameters).
            </summary>
            <typeparam name="Argument1Type"></typeparam>
            <typeparam name="Argument2Type"></typeparam>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="M:Analytics.Functions.GenericBinaryFunction`3.Func(`0,`1)">
            <summary>
            The calculation Function.
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericParametricFunction`3">
            <summary>
            Generic Abstract class for functions with ONE parameter and ONE argument.
            </summary>
            <typeparam name="ParameterType"></typeparam>
            <typeparam name="ArgumentType"></typeparam>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="M:Analytics.Functions.GenericParametricFunction`3.Func(`0,`1)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBinaryParametricFunction`4">
            <summary>
            Generic Abstract class for functions with ONE parameter and TWO arguments.
            </summary>
            <typeparam name="ParameterType"></typeparam>
            <typeparam name="Argument1Type"></typeparam>
            <typeparam name="Argument2Type"></typeparam>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="M:Analytics.Functions.GenericBinaryParametricFunction`4.Func(`0,`1,`2)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p"></param>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBiparametricFunction`4">
            <summary>
            Generic Abstract class for functions with TWO parameters and ONE argument.
            </summary>
            <typeparam name="Parameter1Type"></typeparam>
            <typeparam name="Parameter2Type"></typeparam>
            <typeparam name="ArgumentType"></typeparam>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="M:Analytics.Functions.GenericBiparametricFunction`4.Func(`0,`1,`2)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Functions.GenericBinaryBiparametricFunction`5">
            <summary>
            Generic Abstract class for functions with TWO parameters and TWO arguments.
            </summary>
            <typeparam name="Parameter1Type"></typeparam>
            <typeparam name="Parameter2Type"></typeparam>
            <typeparam name="Argument1Type"></typeparam>
            <typeparam name="Argument2Type"></typeparam>
            <typeparam name="ResultType"></typeparam>
        </member>
        <member name="M:Analytics.Functions.GenericBinaryBiparametricFunction`5.Func(`0,`1,`2,`3)">
            <summary>
            The calculation Function.
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Variables.BooleanVariable">
            <summary>
            The Standard Boolean variable
            (contains Boolean value).
            </summary>
        </member>
        <member name="M:Analytics.Variables.BooleanVariable.Default">
            <summary>
            Default value (False)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.BooleanVariable.#ctor(System.String,System.Boolean)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.BooleanVariable.#ctor(System.String)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.ObjectVariable">
            <summary>
            The General Scalar variable class
            that can contain ONE toolect (of any type).
            The variable data type is determined by the type of the toolect.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectVariable.toolectType">
            <summary>
            The value type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.GetValueType">
            <summary>
            Value Type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns value type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.AssignValueType">
            <summary>
            Assigns Value Type using current information
            (if toolect is not null - gets the type of the toolect,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectVariable.#ctor(System.String,System.Object,System.Type)">
            <summary>
            Constructor
            (the only one aValue or aType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aType">Variable type</param>
        </member>
        <member name="T:Analytics.Variables.ObjectArrayVariable">
            <summary>
            The General Array variable class
            that can contain ONE DIMENTIONAL ARRAY (of any base type).
            The base data type is determined by the type of the array.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectArrayVariable.baseType">
            <summary>
            The Base type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.GetBaseType">
            <summary>
            Array Base type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.GetValueType">
            <summary>
            Array value type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns base type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.AssignBaseType">
            <summary>
            Assigns Base Type using current information
            (if array is not null - gets the type of the array elements,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectArrayVariable.#ctor(System.String,System.Object[],System.Type)">
            <summary>
            Constructor
            (the only one aValue or aBaseType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aBaseType">Base Array type</param>
        </member>
        <member name="T:Analytics.Variables.ObjectMatrixVariable">
            <summary>
            The General Matrix variable class
            that can contain TWO DIMENTIONAL ARRAY - MATRIX (of any base type).
            The base data type is determined by the type of the matrix.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectMatrixVariable.baseType">
            <summary>
            The Base type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.GetBaseType">
            <summary>
            Matrix base type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.GetValueType">
            <summary>
            Matrix value type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns base type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.AssignBaseType">
            <summary>
            Assigns Base Type using current information
            (if array is not null - gets the type of the array elements,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectMatrixVariable.#ctor(System.String,System.Object[0:,0:],System.Type)">
            <summary>
            Constructor
            (the only one aValue or aBaseType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aBaseType">Base Matrix type</param>
        </member>
        <member name="T:Analytics.Variables.ObjectBlockVariable">
            <summary>
            The General Block variable class
            that can contain THREE DIMENTIONAL ARRAY - BLOCK (of any base type).
            The base data type is determined by the type of the block.
            </summary>
        </member>
        <member name="F:Analytics.Variables.ObjectBlockVariable.baseType">
            <summary>
            The Base type
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.GetBaseType">
            <summary>
            Block base type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.GetValueType">
            <summary>
            Block value type
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.SetValue(System.Object)">
            <summary>
            Sets data and assigns base type
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.AssignBaseType">
            <summary>
            Assigns Base Type using current information
            (if array is not null - gets the type of the array elements,
            if null leaves the type unchanged)
            </summary>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.Default">
            <summary>
            Default value (not implemented)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.ObjectBlockVariable.#ctor(System.String,System.Object[0:,0:,0:],System.Type)">
            <summary>
            Constructor
            (the only one aValue or aBaseType can be null)
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
            <param name="aBaseType">Base Block type</param>
        </member>
        <member name="T:Analytics.Variables.RealVariable">
            <summary>
            The Standard Real variable
            (contains Double value).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealVariable.Default">
            <summary>
            Default value (0.0)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealVariable.#ctor(System.String,System.Double)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealVariable.#ctor(System.String)">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.RealArrayVariable">
            <summary>
            The Standard Real Array variable
            (contains Double array).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealArrayVariable.Default">
            <summary>
            Default value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealArrayVariable.#ctor(System.String,System.Double[])">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealArrayVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.RealMatrixVariable">
            <summary>
            The Standard Real Matrix variable
            (contains Double matrix).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealMatrixVariable.Default">
            <summary>
            Default value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealMatrixVariable.#ctor(System.String,System.Double[0:,0:])">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealMatrixVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Variables.RealBlockVariable">
            <summary>
            The Standard Real Block variable
            (contains Double block).
            </summary>
        </member>
        <member name="M:Analytics.Variables.RealBlockVariable.Default">
            <summary>
            Default value 
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Variables.RealBlockVariable.#ctor(System.String,System.Double[0:,0:,0:])">
            <summary>
            Constructor 
            </summary>
            <param name="aName">Variable name</param>
            <param name="aValue">Variable value</param>
        </member>
        <member name="M:Analytics.Variables.RealBlockVariable.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aName">Variable name</param>
        </member>
        <member name="T:Analytics.Formulae.Formula">
            <summary>
            Abstract base class for any formula.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.Formula.resultType">
            <summary>
            Result Type
            </summary>
        </member>
        <member name="M:Analytics.Formulae.Formula.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Analytics.Formulae.Formula.Calculate">
            <summary>
            Calculates Result value for the current state
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.Formula.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.Formula.GetResultTypes(System.Collections.Generic.List{Analytics.Formulae.Formula})">
            <summary>
            Gets formula result types
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.Formula.CalculateArray(System.Int32,Analytics.Formulae.Formula[],System.Object[]@)">
            <summary>
            Calculates all (not null) formulae in arrray and saves values to the result array
            (if some formula is null - assigns null value to the result item).
            </summary>
            <param name="count"></param>
            <param name="a"></param>
            <param name="values"></param>
        </member>
        <member name="P:Analytics.Formulae.Formula.ResultType">
            <summary>
            Result Type
            </summary>
        </member>
        <member name="T:Analytics.Formulae.SimpleFormula">
            <summary>
            Simple formula does not contain any other formula.
            </summary>
        </member>
        <member name="T:Analytics.Formulae.StructuredFormula">
            <summary>
            Structured formula contains other formulae.
            </summary>
        </member>
        <member name="T:Analytics.Formulae.LiteralFormula">
            <summary>
            Literal value
            </summary>
        </member>
        <member name="F:Analytics.Formulae.LiteralFormula.literal">
            <summary>
            Literal value
            </summary>
        </member>
        <member name="M:Analytics.Formulae.LiteralFormula.#ctor(System.Type,System.Object)">
            <summary>
            Constructor
            </summary>
            <param name="t">Type of literal (because value can be null)</param>
            <param name="value">Literal value</param>
        </member>
        <member name="M:Analytics.Formulae.LiteralFormula.Calculate">
            <summary>
            Returns literal value.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.VariableFormula">
            <summary>
            Variable formula - contains reference to a variable (of any type - Scalar, Array...)
            Variable cannot be null, but variable value can.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.VariableFormula.variable">
            <summary>
            Variable
            </summary>
        </member>
        <member name="M:Analytics.Formulae.VariableFormula.Calculate">
            <summary>
            Returns the Variable Value
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Formulae.VariableFormula.#ctor(Analytics.Variables.Variable)">
            <summary>
            Constructor
            </summary>
            <param name="v">Variable (cannot be null)</param>
        </member>
        <member name="T:Analytics.Formulae.IndexingFormula">
            <summary>
            Indexed data Item formula. 
            Contains reference to an Indexed Variable
            and indexes formulae. Result is the data item with the current index values.
            NOTE: Index formulae MUST return values that can be converted to integer values.
                  Now it is Double only. AND the calculated values MUST be with fraction==.000
                  (that is the value must be almost integer - see Constants.RealIndexPrecision).
            NOTE: Slicing implemented for indexed data that supports it.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.source">
            <summary>
            Source array
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.indexcount">
            <summary>
            Index count
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.indexes">
            <summary>
            Index formulae
            </summary>
        </member>
        <member name="F:Analytics.Formulae.IndexingFormula.indexValues">
            <summary>
            Index values
            </summary>
        </member>
        <member name="M:Analytics.Formulae.IndexingFormula.#ctor(Analytics.Variables.IndexedVariable,System.Collections.Generic.List{Analytics.Formulae.Formula})">
            <summary>
            Constructor
            </summary>
            <param name="a">Source indexed variable (CANNOT be null)</param>
            <param name="aindexes">Index Formulae (CANNOT be null)</param>
        </member>
        <member name="M:Analytics.Formulae.IndexingFormula.Calculate">
            <summary>
            Returns array item for the current index values
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.FunctionFormula">
            <summary>
            Function formula.
            Contains reference to a function calculation method
            parameter and argument formulae.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.function">
            <summary>
            Source function
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.parametercount">
            <summary>
            Parameter count
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.argumentcount">
            <summary>
            Argument count
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.parameters">
            <summary>
            Parameter Formulae
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.arguments">
            <summary>
            Argument Formulae
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.parameterValues">
            <summary>
            Parameter values
            </summary>
        </member>
        <member name="F:Analytics.Formulae.FunctionFormula.argumentValues">
            <summary>
            Argument values
            </summary>
        </member>
        <member name="M:Analytics.Formulae.FunctionFormula.#ctor(Analytics.Functions.Function,System.Collections.Generic.List{Analytics.Formulae.Formula},System.Collections.Generic.List{Analytics.Formulae.Formula})">
            <summary>
            Constructor.
            The count and types of parameter and argument formulae must
            be the same as of Function (types must be compatible).
            </summary>
            <param name="f">Function (CANNOT be null)</param>
            <param name="prms"></param>
            <param name="args"></param>
        </member>
        <member name="M:Analytics.Formulae.FunctionFormula.Calculate">
            <summary>
            Calculates Function value for the current parameter and argument values.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.UnaryOperationFormula">
            <summary>
            Unary Operation Formula.
            Cantains reference to an Unary Operation method and an Operand Formula.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.UnaryOperationFormula.operation">
            <summary>
            Operation
            </summary>
        </member>
        <member name="F:Analytics.Formulae.UnaryOperationFormula.operand">
            <summary>
            Operand
            </summary>
        </member>
        <member name="F:Analytics.Formulae.UnaryOperationFormula.operandValue">
            <summary>
            (1) Operand value
            </summary>
        </member>
        <member name="M:Analytics.Formulae.UnaryOperationFormula.#ctor(Analytics.Operators.UnaryOperator,Analytics.Formulae.Formula)">
            <summary>
            Constructor.
            </summary>
            <param name="op">Operator (CANNOT be null)</param>
            <param name="opnd">Operand (CANNOT be null)</param>
        </member>
        <member name="M:Analytics.Formulae.UnaryOperationFormula.Calculate">
            <summary>
            Calculates unary operation result for the current operand value
            </summary>
            <returns></returns>
        </member>
        <member name="T:Analytics.Formulae.BinaryOperationsFormula">
            <summary>
            Binary Operation Formula.
            Contains reference to a sequence of Binary Operation methods and their Operand Formulae.
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operations">
            <summary>
            Operations
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operands">
            <summary>
            Operands
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operandValues">
            <summary>
            Operand values (in the order of calculation)
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operatorOperands">
            <summary>
            Operand values for an operator (two operands)
            </summary>
        </member>
        <member name="F:Analytics.Formulae.BinaryOperationsFormula.operationcount">
            <summary>
            Count of operations
            </summary>
        </member>
        <member name="M:Analytics.Formulae.BinaryOperationsFormula.#ctor(Analytics.Operators.BinaryOperator[],Analytics.Formulae.Formula[])">
            <summary>
            Constructor.
            NOTE: The number of operands must be the number of operators +1.
                  The number of operators CAN be 0, because it must be compatible
                  whith Expression realization (binary operations expression
                  can be degenerated during simplification, so it can contain one operand only).
            </summary>
            <param name="ops">Binary Operators (CANNOT be null)</param>
            <param name="opnds">Operands (CANNOT be null)</param>
        </member>
        <member name="M:Analytics.Formulae.BinaryOperationsFormula.Calculate">
            <summary>
            Calculates the sequence of binary operations for the current operand values
            (returns the last operation result).
            TODO: now the operator associativity is not taken into account
                  (LEFT associativity is applied)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Formulae.BinaryOperationsFormula.OperationCount">
            <summary>
            Count of operations
            </summary>
        </member>
        <member name="T:Analytics.OperatorSet">
            <summary>
            Set of operators
            </summary>
        </member>
        <member name="F:Analytics.OperatorSet.data">
            <summary>
            Operators
            Each array index corresponds to the Operator Type.
            Undefined operator list is always null.
            </summary>
        </member>
        <member name="M:Analytics.OperatorSet.RecreateData">
            <summary>
            Recreates data
            </summary>
        </member>
        <member name="M:Analytics.OperatorSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.OperatorSet.Add(Analytics.Operators.Operator)">
            <summary>
            Adds the operator to the list
            </summary>
            <param name="op"></param>
        </member>
        <member name="M:Analytics.OperatorSet.FindUnary(Analytics.OperatorType,System.Type)">
            <summary>
            Finds unary operator
            </summary>
            <param name="type"></param>
            <param name="operand"></param>
            <returns>Unary operator or null</returns>
        </member>
        <member name="M:Analytics.OperatorSet.FindBinary(Analytics.OperatorType,System.Type,System.Type)">
            <summary>
            Finds binary operator
            </summary>
            <param name="type"></param>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns>Binary operator or null</returns>
        </member>
        <member name="M:Analytics.OperatorSet.Clear">
            <summary>
            Clears all data
            </summary>
        </member>
        <member name="M:Analytics.OperatorSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.OperatorSet.Item(Analytics.OperatorType)">
            <summary>
            Indexing by Operator Type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.FunctionSet">
            <summary>
            Set of functions
            </summary>
        </member>
        <member name="F:Analytics.FunctionSet.data">
            <summary>
            Functions
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.RecreateData">
            <summary>
            Recreates data
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.FindExact(System.Collections.Generic.List{Analytics.Functions.Function},System.Type[],System.Type[])">
            <summary>
            Finds function by types (exact coincidence)
            </summary>
            <param name="values"></param>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns>Function or null</returns>
        </member>
        <member name="M:Analytics.FunctionSet.FindCompatible(System.Collections.Generic.List{Analytics.Functions.Function},System.Type[],System.Type[])">
            <summary>
            Finds function by types (compatibility)
            </summary>
            <param name="values"></param>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns>Function or null</returns>
        </member>
        <member name="M:Analytics.FunctionSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.Add(Analytics.Functions.Function)">
            <summary>
            Add a function to the dictionary
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Analytics.FunctionSet.FindFunction(System.String,System.Type[],System.Type[])">
            <summary>
            Finds function by name and types
            </summary>
            <param name="name"></param>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns>Function or null</returns>
        </member>
        <member name="M:Analytics.FunctionSet.Clear">
            <summary>
            Clears all data
            </summary>
        </member>
        <member name="M:Analytics.FunctionSet.GetAll">
            <summary>
            Gets all functions
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.FunctionSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.FunctionSet.Item(System.String)">
            <summary>
            Indexing by function name
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.OperationSet">
            <summary>
            Operations class contains a set of (registered) operators and functions
            (that is operations applicable to data of some types) used to build formulae.
            </summary>
        </member>
        <member name="F:Analytics.OperationSet.operators">
            <summary>
            Operators
            </summary>
        </member>
        <member name="F:Analytics.OperationSet.functions">
            <summary>
            Functions
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.RecreateData">
            <summary>
            Recteates data
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.GetAllFunctions">
            <summary>
            Gets all registered functions
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.OperationSet.UpdateDefault">
            <summary>
            Updates default data
            </summary>
        </member>
        <member name="M:Analytics.OperationSet.Print">
            <summary>
            Gets information string (for tests only)
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.OperationSet.Operators">
            <summary>
            Operator set
            </summary>
        </member>
        <member name="P:Analytics.OperationSet.Functions">
            <summary>
            Function set
            </summary>
        </member>
        <member name="T:Analytics.AutoOperations">
            <summary>
            Automatic Operations class registers all operator and function
            types using reflection mechanisms.
            NOTE: registers only SEALED classes (it is a hook to not use Run-time operators)
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.UpdateRegisteredOperators">
            <summary>
            Finds all operator types and adds operators to the operator set.
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.UpdateRegisteredFunctions">
            <summary>
            Finds all function types and adds functions to the function set.
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.AutoOperations.UpdateDefault">
            <summary>
            Updates default data
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.CharacterRule">
            <summary>
            A 'rule' for some character in a string.
            </summary>
            <param name="value">String value</param>
            <param name="index">The character index in the string value</param>
            <returns>True, if the rule is fulfilled</returns>
        </member>
        <member name="T:Analytics.Syntactic.CharacterRuleSet">
            <summary>
            Character rule set
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.CharacterRuleSet.rules">
            <summary>
            Rules
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.CharacterRuleSet.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.CharacterRuleSet.SetRule(System.Char,Analytics.Syntactic.CharacterRule)">
            <summary>
            Sets new rule for a character
            (if there are rules for a character - adds it to the list,
            else creates new list for the character)
            </summary>
            <param name="character"></param>
            <param name="rule"></param>
        </member>
        <member name="M:Analytics.Syntactic.CharacterRuleSet.CheckRules(System.Char,System.String,System.Int32)">
            <summary>
            Checks if ALL rules are fulfilled for a character.
            </summary>
            <param name="symbol"></param>
            <param name="value"></param>
            <param name="index"></param>
            <returns>True, if all rules returne true or no rule exists</returns>
        </member>
        <member name="T:Analytics.Syntactic.Parser">
            <summary>
            Syntactic Parser
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Parser.evaluators">
            <summary>
            Literal Evaluators
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Parser.OperatorRules">
            <summary>
            Rules for operator parsing
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.#cctor">
            <summary>
            Initializes all static data for parsing
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsValidName(System.String)">
            <summary>
            Checks if string is a valid name
            (contains alpha-numerics, '_' and SUBSCRIPT and SUPERSCRIPT DIGITS only and the first character is a letter,
             imaginary unit symbol allowed for name).
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsExponentSign(System.String,System.Int32)">
            <summary>
            Checks if the sign is a part of exponential number representation
            1.23E-4  5.67E+8  9.01e-2  3.45e+6
            (1.E-1 not allowed)
            </summary>
            <param name="value"></param>
            <param name="index"></param>
            <returns>True, if is</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsNotExponentSign(System.String,System.Int32)">
            <summary>
            Sign is NOT a part of exponent number.
            </summary>
            <param name="value"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPrefixSign(System.String,System.Int32)">
            <summary>
            Checks if the sign is a prefix unary (not binary)
            (cases: 1. The sign is the first character of the string)
                    2. The sign is right after a bracket
                    3. The sign is right after power operator
                    4. TODO: Think about OTHER cases...
            </summary>
            <param name="value"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsNotPrefixSign(System.String,System.Int32)">
            <summary>
            Checks if the sign is NOT a prefix unary
            </summary>
            <param name="value"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsOpening(System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Finds opening symbol in a pair list
            </summary>
            <param name="c"></param>
            <param name="pairs"></param>
            <returns>Number of pair, or -1 if not found</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsClosing(System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Finds closing symbol in a pair list
            </summary>
            <param name="c"></param>
            <param name="pairs"></param>
            <returns>Number of pair, or -1 if not found</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.UpdateLevel(System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Int32[]@,System.Int32@)">
            <summary>
            Updates level for a list of pairs checking pair 
            compatibility and errors
            (the total level is a sum of levels
            or negative, if one level is negative - error)
            </summary>
            <param name="c"></param>
            <param name="pairs"></param>
            <param name="levels"></param>
            <param name="total"></param>
        </member>
        <member name="M:Analytics.Syntactic.Parser.GetSubstring(System.String,Analytics.Syntactic.PairIndexes)">
            <summary>
            Gets substring (INCLUDING boundary chars)
            </summary>
            <param name="value"></param>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.GetSubstringInside(System.String,Analytics.Syntactic.PairIndexes)">
            <summary>
            Gets substring (EXCLUDING boundary chars)
            </summary>
            <param name="value"></param>
            <param name="indexes"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.FindPairMultilevel(System.String,System.Int32,Analytics.Syntactic.SymbolPair,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},Analytics.Syntactic.PairIndexes@)">
            <summary>
            Finds pair of the first level
            (NOTE: does not check the levels sintax -
                   pairs can be uncompatible - "[}" for an example)
            TODO: Fix it;
            </summary>
            <param name="value"></param>
            <param name="first"></param>
            <param name="pair"></param>
            <param name="levels"></param>
            <param name="indexes"></param>
            <returns>True, if found, if false - indexes indicates an error
            (-1,-1) - no pair of the first level
            (-1, >0) - opening expected
            (>=0, -1) - closing expected</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.SplitMultilevel(System.String,System.Collections.Generic.List{System.Char},System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Boolean,Analytics.Syntactic.CharacterRuleSet,System.Collections.Generic.List{System.Char}@)">
            <summary>
            Splits string by many separators using open-close pairs
            (checks errors of open-close pairs).
            Zero items (two separators beside) not allowed.
            </summary>
            <param name="value"></param>
            <param name="separators"></param>
            <param name="levels"></param>
            <param name="checkpairs">If false, does not check the pair open close and if error - returns the last
            part of the values as an item</param>
            <param name="rules"></param>
            <param name="splitters"></param>
            <returns>List of items, or null if there are open-close errors</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.SplitMultilevel(System.String,System.Collections.Generic.List{System.Char},System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Boolean,System.Collections.Generic.List{System.Char}@)">
            <summary>
            Splits string by many separators using open-close pairs
            (checks errors of open-close pairs).
            Zero items (two separators beside) not allowed.
            </summary>
            <param name="value"></param>
            <param name="separators"></param>
            <param name="levels"></param>
            <param name="checkpairs">If false, does not check the pair open close and if error - returns the last
            part of the values as an item</param>
            <param name="splitters"></param>
            <returns>List of items, or null if there are open-close errors</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.SplitMultilevel(System.String,System.Char,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.Boolean)">
            <summary>
            Splits string by separator using open-close pairs
            (checks errors of open-close pairs, does not includes empty items)
            </summary>
            <param name="value"></param>
            <param name="separator"></param>
            <param name="levels"></param>
            <param name="checkpairs">If false, does not check the pair open close and if error - returns the last
            part of the values as an item</param>
            <returns>List of items, or null if there are open-close errors</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsSurrounded(System.String,Analytics.Syntactic.SymbolPair,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair},System.String@)">
            <summary>
            Checks if the string is surrounded by a pair of symbols.
            </summary>
            <param name="value"></param>
            <param name="pair"></param>
            <param name="levels"></param>
            <param name="inside"></param>
            <returns>True, if is surrounded</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.RemoveSurrounders(System.String,Analytics.Syntactic.SymbolPair,System.Collections.Generic.List{Analytics.Syntactic.SymbolPair})">
            <summary>
            Removes all enclosing pairs
            </summary>
            <param name="value"></param>
            <param name="pair"></param>
            <param name="levels"></param>
            <returns>String without enclosing pairs</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsFunction(System.String,System.String@,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Checks if a string value has 'function like' format.
            NOTE: Does not check that the name is valid and parameters contain no errors.
            General function format
            name{p1 p2 ... pk}(a1 a2 ... an) - arguments are obligatory, parameters are not obligatory.
            the count of parameters and arguments can be 0, name cannot be empty.
            </summary>
            <param name="value"></param>
            <param name="name">Name of the function, cannot be empty</param>
            <param name="parameters">Parameters, can be null</param>
            <param name="arguments">Arguments, can be null</param>
            <returns>True, if the string has right format</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsArrayItem(System.String,System.String@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Checks if a string value has 'array like' format.
            General (multidimentional) array format
            name[index1][index2]...[indexN]
            indexes can be empty strings.
            NOTE: does not check that indexes have valid format
                  (open-close compatibility only checked, because it is needed for array format)
            </summary>
            <param name="value"></param>
            <param name="name"></param>
            <param name="indexes"></param>
            <returns>True, if valid format</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsReal(System.String,System.Globalization.CultureInfo,System.Double@)">
            <summary>
            Checks if the string represents a Real value.
            NOTE: Automatically detects Infinity, Pi, E (see Symbols class).
            </summary>
            <param name="value"></param>
            <param name="culture"></param>
            <param name="x"></param>
            <returns>True, if valid</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsReal(System.String,System.Double@)">
            <summary>
            Checks if the string represents a Real value (for CURRENT CULTURE)
            </summary>
            <param name="value"></param>
            <param name="x"></param>
            <returns>True, if valid</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsReal(System.String)">
            <summary>
            Checks if the string represents a Real value (for CURRENT CULTURE)
            </summary>
            <param name="value"></param>
            <returns>True, if valid</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsRealConstant(System.Double,System.String@)">
            <summary>
            Checks if the real number is a standard constant (Pi, e, ...).
            WARNING: Detection algorithm is based on comparison with the Constants.RealConstantPrecision value. 
            </summary>
            <param name="x"></param>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateReal(System.String,System.Type@)">
            <summary>
            Evaluates real literal.
            </summary>
            <param name="value"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplex(System.String,System.Globalization.CultureInfo,System.Numerics.Complex@)">
            <summary>
            Checks if the string represents a Complex value.
            Complex value syntax examples: 1.2+2.3I 
                                           -2.3I
                                           4I
                                           I
                                           -1.2e-3+4.5e+2I
                                           1.2e+2I
            TODO: think about other formats.
            </summary>
            <param name="value"></param>
            <param name="culture"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplex(System.String,System.Numerics.Complex@)">
            <summary>
            Checks if the string represents a Complex value (for CURRENT CULTURE).
            </summary>
            <param name="value"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplex(System.String)">
            <summary>
            Checks if the string represents a Complex value (for CURRENT CULTURE).
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsComplexConstant(System.Numerics.Complex,System.String@)">
            <summary>
            Checks if the complex number can be simplified (I, 0, ...).
            WARNING: Detection algorithm is based on comparison with the Constants.RealConstantPrecision value. 
            </summary>
            <param name="z"></param>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateComplex(System.String,System.Type@)">
            <summary>
            Evaluates complex literal.
            </summary>
            <param name="value"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.ComplexToString(System.Numerics.Complex)">
            <summary>
            Converts complex to string.
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBoolean(System.String,System.Globalization.CultureInfo,System.Boolean@)">
            <summary>
            Checks if the string represents a Boolean value.
            </summary>
            <param name="value"></param>
            <param name="culture"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBoolean(System.String,System.Boolean@)">
            <summary>
            Checks if the string represents a Boolean value for the current culture.
            </summary>
            <param name="value"></param>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBoolean(System.String)">
            <summary>
            Checks if the string represents a Boolean value for the current culture.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateBoolean(System.String,System.Type@)">
            <summary>
            Evaluates boolean value.
            </summary>
            <param name="value"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.RegisterLiteralEvaluator(Analytics.LiteralIs,Analytics.LiteralEvaluate)">
            <summary>
            Registers Literal Evaluator.
            </summary>
            <param name="li"></param>
            <param name="le"></param>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsLiteral(System.String)">
            <summary>
            Checks if the string is a literal.
            </summary>
            <param name="literal"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.EvaluateLiteral(System.String,System.Object@,System.Type@)">
            <summary>
            Evaluates literal.
            </summary>
            <param name="literal"></param>
            <param name="result"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsBinaryExpression(System.String,System.Collections.Generic.List{System.Char},System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Check, if the string is a binary operations expression
            (can be devided into a sequence of expressions by some operators)
            </summary>
            <param name="value"></param>
            <param name="signs"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns>True, if is</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsLogicalExpression(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Check, if the string is a 'logical' expression
            (can be devided into a sequence of expressions by And, Or operators)
            </summary>
            <param name="value"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsRelationalExpression(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Check, if the string is a 'relational' expression
            (can be devided into a sequence of expressions by Greater, Less, Equal etc. operators)
            </summary>
            <param name="value"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsSummExpression(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Check, if the string is a 'summ' expression
            (can be devided into a sequence of expressions by + and - operators)
            </summary>
            <param name="value"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns>True, if the string is a summ expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsProductExpression(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Check, if the string is a 'product' expression
            (can be devided into a sequence of expressions by * and / operators)
            </summary>
            <param name="value"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns>True, if the string is a product expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPowerExpression(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Check, if the string is a 'power' expression
            (can be devided into a sequence of expressions by ^ operator)
            </summary>
            <param name="value"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns>True, if the string is a power expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsArrowExpression(System.String,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.String}@)">
            <summary>
            Check, if the string is an 'arrow' expression
            (can be devided into a sequence of expressions by Arrow operators)
            </summary>
            <param name="value"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns>True, if the string is an Arrow expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPrefixExpression(System.String,System.String@,System.String@)">
            <summary>
            The string value is a PREFIX expression
            (the first character is a prefix operator)
            </summary>
            <param name="value"></param>
            <param name="operand"></param>
            <param name="operat"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsPostfixExpression(System.String,System.String@,System.String@)">
            <summary>
            The string value is a POSTFIX expression
            (the last character is a postfix operator)
            </summary>
            <param name="value"></param>
            <param name="operand"></param>
            <param name="operat"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.Parser.IsAbsoluteExpression(System.String,System.String@)">
            <summary>
            The string is absolute value expression |some operand expression|
            </summary>
            <param name="value"></param>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Derivatives.FunctionalDerivative">
            <summary>
            Base abstract class to define derivative for a function.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.GetFunctionName">
            <summary>
            Returns the name of the function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.GetParameterCount">
            <summary>
            Returns the function parameter count.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.GetArgumentCount">
            <summary>
            Returns the function argument count.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Derivatives.FunctionalDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Derivative calculation for the function.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Derivatives.FunctionalDerivative.FunctionName">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.FunctionalDerivative.ParameterCount">
            <summary>
            Parameter count
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.FunctionalDerivative.ArgumentCount">
            <summary>
            Argument count
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.CompositeFunctionalDerivative">
            <summary>
            Base abstract class to define derivative function with one argument.
            Overrides Derivative method, based on the 'chain rule' formula
            d(f(g(x)))/dx = df/dg * dg/dx
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.CompositeFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Creates derivative expression specific for the function.
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Derivatives.CompositeFunctionalDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Overrides Derivative method, based on the formula
            d(f(g(x)))/dx = df/dg * dg/dx
            </summary>
            <param name="context"></param>
            <param name="function"></param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Derivatives.CompositeParametricDerivative">
            <summary>
            Base abstract class to define derivative function with one argument and (any number of) parameters
            that do not depend on the derivation variable. So, the derivation process also based on the.
            'chain rule' formula d(f(g(x)))/dx = df/dg * dg/dx
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.CompositeParametricDerivative.CheckParameters(Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Checks all parameters for no dependency on the variable.
            </summary>
            <param name="function"></param>
            <param name="vName"></param>
        </member>
        <member name="M:Analytics.Derivatives.CompositeParametricDerivative.Derivative(Analytics.Derivatives.DerivativeContext,Analytics.Syntactic.FunctionExpression,System.String)">
            <summary>
            Overrides Derivative method, introducing parameters checking for no dependency on the variable.
            </summary>
            <param name="context"></param>
            <param name="function"></param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Derivatives.SimpleFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for simple
            function with one argument (and no parameters).
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.SimpleFunctionalDerivative.BaseDerivative(Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates base derivative expression for the function's argument (df/dg).
            For an example, for the sine function it is cosine function of the same argument.
            </summary>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Derivatives.SimpleFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative for simple case of 1 argument.
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Derivatives.ParametricFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for parametric
            function - with one parameter and one argument
            (for such functions, as log and special functions).
            WARNING: The class's base does override Derivative method by checking all parameters for no dependency on 
                     the derivation variable. If the derivative can be defined for functional parameters - override entire Derivative.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.ParametricFunctionalDerivative.BaseDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for the case of 1 parameter and 1 argument.
            </summary>
            <param name="parameter"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Derivatives.ParametricFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative for the case of 1 parameter and 1 argument.
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Derivatives.BiparametricFunctionalDerivative">
            <summary>
            Base abstract class to define derivative for bi-parametric
            function - with two parameters and one argument
            (mainly for special functions - Legendre polinomial for an example).
            WARNING: The class's base does override Derivative method by checking all parameters for no dependency on 
                     the derivation variable. If the derivative can be defined for functional parameters - override entire Derivative.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.BiparametricFunctionalDerivative.BaseDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Overrides function derivative for the case of 2 parameters and 1 argument.
            </summary>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Derivatives.BiparametricFunctionalDerivative.FunctionDerivative(Analytics.Syntactic.FunctionExpression)">
            <summary>
            Overrides function derivative for the case of 2 parameters and 1 argument.
            </summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Derivatives.DerivativeContext">
            <summary>
            Base class for Analytical Derivative Calculation context data
            (registers function derivatives).
            </summary>
        </member>
        <member name="F:Analytics.Derivatives.DerivativeContext.functions">
            <summary>
            List of functional derivatives
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.GetIndex(System.String,System.Int32,System.Int32)">
            <summary>
            Finds function index by parameters
            </summary>
            <param name="func"></param>
            <param name="pcount"></param>
            <param name="acount"></param>
            <returns>index or -1</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Add(Analytics.Derivatives.FunctionalDerivative)">
            <summary>
            Adds function derivative (if there is no function with the same arguments).
            </summary>
            <param name="d"></param>
            <returns>True if added</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Set(Analytics.Derivatives.FunctionalDerivative)">
            <summary>
            Sets function, if there is function with the same arguments,
            or adds it, if not.
            </summary>
            <param name="d"></param>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Remove(System.String,System.Int32,System.Int32)">
            <summary>
            Romoves function derivative by parameters
            </summary>
            <param name="func"></param>
            <param name="pcount"></param>
            <param name="acount"></param>
            <returns>True, if removed</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Remove(System.Int32)">
            <summary>
            Romoves function derivative by index
            </summary>
            <param name="index"></param>
            <returns>True, if removed</returns>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.Clear">
            <summary>
            Clears the entire context
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.DerivativeContext.UpdateDefault">
            <summary>
            Updates default context.
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.DerivativeContext.FunctionDerivatives">
            <summary>
            Lazy initialized set of Function Derivatives for protected use.
            </summary>
        </member>
        <member name="P:Analytics.Derivatives.DerivativeContext.Item(System.String,System.Int32,System.Int32)">
            <summary>
            Finds Function Derivative by its parameters.
            </summary>
            <param name="func"></param>
            <param name="pcount"></param>
            <param name="acount"></param>
            <returns>Function derivative or null if no match found</returns>
        </member>
        <member name="P:Analytics.Derivatives.DerivativeContext.FunctionCount">
            <summary>
            Function count
            </summary>
        </member>
        <member name="T:Analytics.Derivatives.AutoDerivativeContext">
            <summary>
            Automative derivative context.
            (automatically finds and registers all functional derivative classes).
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.AutoDerivativeContext.UpdateRegisteredFunctions">
            <summary>
            Automatically finds and registers functional derivatives
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.AutoDerivativeContext.UpdateDefault">
            <summary>
            Finds and registers all nonabstract sealed function derivatives.
            </summary>
        </member>
        <member name="M:Analytics.Derivatives.AutoDerivativeContext.#ctor">
            <summary>
            Default constructor (automatically finds and registers context data)
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.SymbolPair">
            <summary>
            Opening-Closing symbol pair
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.#ctor(System.Char,System.Char)">
            <summary>
            Constructor
            </summary>
            <param name="c1"></param>
            <param name="c2"></param>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.Counter(System.Char)">
            <summary>
            Opening-closing counter
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.op_Equality(Analytics.Syntactic.SymbolPair,Analytics.Syntactic.SymbolPair)">
            <summary>
            ==
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.op_Inequality(Analytics.Syntactic.SymbolPair,Analytics.Syntactic.SymbolPair)">
            <summary>
            !=
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.Equals(System.Object)">
            <summary>
            ==
            </summary>
            <param name="tool"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SymbolPair.GetHashCode">
            <summary>
            Hash code
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.SymbolPair.Opening">
            <summary>
            Opening symbol
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.SymbolPair.Closing">
            <summary>
            Closing symbol
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.PairIndexes">
            <summary>
            Pair Indexes
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PairIndexes.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="i1"></param>
            <param name="i2"></param>
        </member>
        <member name="M:Analytics.Syntactic.PairIndexes.ToString">
            <summary>
            ToString
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.Index1">
            <summary>
            The First Index
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.Index2">
            <summary>
            The Second Index
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.Length">
            <summary>
            Total length (including indexes) - calculated
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.PairIndexes.LengthInside">
            <summary>
            Length of inside items (excluding indexes) - calculated
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.Elements">
            <summary>
            Syntactic elements
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.FunctionBrackets">
            <summary>
            Function Brackets Pair
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.IndexBrackets">
            <summary>
            Index Brackets Pair
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.ParameterBrackets">
            <summary>
            Parameter Brackets Pair
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.Elements.Brackets">
            <summary>
            All Brackets
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.Elements.#cctor">
            <summary>
            Initializes all static data elements
            </summary>
        </member>
        <member name="T:Analytics.Operators.BooleanNotOperator">
            <summary>
            Logical Not operator
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericNotOperator`1">
            <summary>
            Base Generic class for Logical Not operators
            </summary>
            <typeparam name="OperandType"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericUnaryBooleanOperator`1">
            <summary>
            Abstract Generic Unary operator with boolean return type. 
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUnaryOperator`2">
            <summary>
            Abstract Generic Unary operator. 
            </summary>
        </member>
        <member name="T:Analytics.Operators.UnaryOperator">
            <summary>
            Base abstract class for ALL Unary operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.Operator">
            <summary>
            Base abstract class for all operators
            </summary>
        </member>
        <member name="M:Analytics.Operators.Operator.GetOperatorType">
            <summary>
            Operator type
            (must be implemented in intermediate abstract class
            as final and cannot be overriden in inherited classes)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.Operator.GetReturnType">
            <summary>
            Return type (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.Operator.DoOperation(System.Object[])">
            <summary>
            Does operation
            (must be implemented in intermediate class (Unary, Binary)
            and cannot be overriden in inherited classes)
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.Operator.Calculate(System.Object[])">
            <summary>
            Calculates operation result
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Operators.Operator.Type">
            <summary>
            Type of operator 
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.ReturnType">
            <summary>
            Type of result 
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.Arity">
            <summary>
            Arity (depends on Operator Type)
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.Position">
            <summary>
            Position (depends on Operator Type)
            </summary>
        </member>
        <member name="P:Analytics.Operators.Operator.Sign">
            <summary>
            Operator Sign (depends on Operator Type)
            </summary>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.GetOperandType">
            <summary>
            Operand type
            (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.Operation(System.Object)">
            <summary>
            Operation with one operand
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.DoOperation(System.Object[])">
            <summary>
            Does operation with one operand
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.UnaryOperator.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Operators.UnaryOperator.OperandType">
            <summary>
            Type of operand 
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericUnaryOperator`2.TypedOperation(`0)">
            <summary>
            Typed Unary Operator Operation.
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.GenericUnaryOperator`2.Operation(System.Object)">
            <summary>
            Overrides Unary Operator Operation replacing it
            by typed one with automatic operand cast.
            </summary>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.BooleanAndOperator">
            <summary>
            Logical And operator
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericAndOperator`2">
            <summary>
            Base Generic class for Logical And operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericBinaryBooleanOperator`2">
            <summary>
            Abstract Generic Binary operator with boolean return type. 
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericBinaryOperator`3">
            <summary>
            Abstract Generic Binary operator.
            </summary>
        </member>
        <member name="T:Analytics.Operators.BinaryOperator">
            <summary>
            Base abstract class for ALL Binary operators
            </summary>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.GetOperand1Type">
            <summary>
            Operand 1 type
            (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.GetOperand2Type">
            <summary>
            Operand 2 type
            (must be implemented in final class)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.Operation(System.Object,System.Object)">
            <summary>
            Operation with two operands
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.DoOperation(System.Object[])">
            <summary>
            Does operation with two operands
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.BinaryOperator.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Operators.BinaryOperator.Operand1Type">
            <summary>
            Type of 1st operand 
            </summary>
        </member>
        <member name="P:Analytics.Operators.BinaryOperator.Operand2Type">
            <summary>
            Type of 2nd operand 
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericBinaryOperator`3.TypedOperation(`0,`1)">
            <summary>
            Typed Binary Operator Operation.
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Operators.GenericBinaryOperator`3.Operation(System.Object,System.Object)">
            <summary>
            Overrides Binary Operator Operation replacing it
            by typed one with automatic operands cast.
            </summary>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.BooleanOrOperator">
            <summary>
            Logical Or operator
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericOrOperator`2">
            <summary>
            Base Generic class for Logical Or operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.RealQuestionOperator">
            <summary>
            Real to Boolean conversion
            (True if value is not 0.0)
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericQuestionOperator`2">
            <summary>
            Base Generic class for Question (?) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.BoolNumberOperator">
            <summary>
            Boolean to Real conversion (False - 0, True - 1)
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericNumberOperator`2">
            <summary>
            Base Generic class for Number (#) operators
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.ExpressionBuilder">
            <summary>
            Expression builder.
            Realizes methods for building complex (string) expressions
            from simplier (string) expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.Surround(System.String,Analytics.Syntactic.SymbolPair,System.Boolean)">
            <summary>
            Surrounds a string by a pair of symbols
            </summary>
            <param name="value">String value</param>
            <param name="bounds">Symbols to surround with</param>
            <param name="empty">Must empty string be surrounded</param>
            <returns>Surrounded string (or empty string)</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.MakeList(System.Collections.Generic.List{System.String},System.String)">
            <summary>
            Makes list expression (items separated by a separator)
            </summary>
            <param name="values">Items</param>
            <param name="separator">Separator</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.MakeList(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
            Makes list of same expression (items separated by a separator)
            </summary>
            <param name="value">Expression</param>
            <param name="separator">Separator</param>
            <param name="count">Count of values</param>
            <param name="addNumber">Add the number of expression</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.MakeList(System.String,System.Int32,System.Boolean)">
            <summary>
            Makes list of same expression
            </summary>
            <param name="value"></param>
            <param name="count"></param>
            <param name="addNumber"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.MakeList(System.Collections.Generic.List{System.String},System.String,Analytics.Syntactic.SymbolPair,System.Boolean)">
            <summary>
            Makes list expression and surrounds it by a pair of symbols
            </summary>
            <param name="values">Items</param>
            <param name="separator">Separator</param>
            <param name="bounds">Symbols to surround with</param>
            <param name="empty">Must an empty value be surrounded</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.MakeMultilist(System.Collections.Generic.List{System.String},Analytics.Syntactic.SymbolPair)">
            <summary>
            Makes multilist expression - a sequence of items surrounded by a symbol pair
            (empty items are surrounded by symbols too)
            </summary>
            <param name="values">Items</param>
            <param name="bounds">Symbols to surround with</param>
            <returns>String value</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.BuildArrayIndexes(System.Collections.Generic.List{System.String})">
            <summary>
            Builds an array index expression
            </summary>
            <param name="indexes">Indexes</param>
            <returns>Array index expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.BuildFunctionParameters(System.Collections.Generic.List{System.String})">
            <summary>
            Builds a function parameters expression
            </summary>
            <param name="parameters">Parameters</param>
            <returns>Function parameters expression (can be empty string)</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.BuildFunctionArguments(System.Collections.Generic.List{System.String})">
            <summary>
            Builds a function arguments expression
            </summary>
            <param name="arguments">Arguments</param>
            <returns>Function arguments expression (cannot be empty string)</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.BuildArrayItem(System.String,System.Collections.Generic.List{System.String})">
            <summary>
            Builds an array expression
            </summary>
            <param name="name">Array name</param>
            <param name="indexes">Indexes</param>
            <returns>Array expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.BuildFunction(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String})">
            <summary>
            Builds a function expression
            </summary>
            <param name="name">Function name</param>
            <param name="parameters">Parameters</param>
            <param name="arguments">Arguments</param>
            <returns>Function expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.BuildUnaryOperation(System.String,System.String,Analytics.OperatorPosition,System.Boolean)">
            <summary>
            Builds unary operation expression
            </summary>
            <param name="op"></param>
            <param name="operand"></param>
            <param name="position"></param>
            <param name="enclose">Enclose operand by parantheses</param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ExpressionBuilder.BuildBinaryOperations(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.Boolean})">
            <summary>
            Builds binary operations expression.
            Tne operator count must be equal to the operand count - 1.
            </summary>
            <param name="operands"></param>
            <param name="operators"></param>
            <param name="enclose">Enclose operands by parantheses</param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Types">
            <summary>
            Types
            </summary>
        </member>
        <member name="F:Analytics.Types.BooleanType">
            <summary>
            Boolean type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealType">
            <summary>
            Real type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealArrayType">
            <summary>
            Real Array type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealMatrixType">
            <summary>
            Real Matrix type
            </summary>
        </member>
        <member name="F:Analytics.Types.RealBlockType">
            <summary>
            Real Block type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexType">
            <summary>
            Complex type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexArrayType">
            <summary>
            Complex Array type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexMatrixType">
            <summary>
            Complex Matrix type
            </summary>
        </member>
        <member name="F:Analytics.Types.ComplexBlockType">
            <summary>
            Complex Block type
            </summary>
        </member>
        <member name="M:Analytics.Types.#cctor">
            <summary>
            Static constructor (initializes all data)
            </summary>
        </member>
        <member name="T:Analytics.Constants">
            <summary>
            Constants
            </summary>
        </member>
        <member name="F:Analytics.Constants.IntegerValuePrecision">
            <summary>
            Precision for REAL values to be considered as Integer
            </summary>
        </member>
        <member name="F:Analytics.Constants.RealConstantPrecision">
            <summary>
            Precision for real values to be concidered as 'standard' constants - Pi, e and so on.
            </summary>
        </member>
        <member name="F:Analytics.Constants.RealEqualityPrecision">
            <summary>
            Precision for comparison real values to be concidered as equal.
            </summary>
        </member>
        <member name="M:Analytics.Constants.#cctor">
            <summary>
            Static constructor (initializes all data)
            </summary>
        </member>
        <member name="T:Analytics.LiteralIs">
            <summary>
            Is literal method
            </summary>
            <param name="literal"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.LiteralEvaluate">
            <summary>
            Literal Evaluation method
            </summary>
            <param name="literal"></param>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.FunctionMethod">
            <summary>
            Function calculation method
            </summary>
            <param name="parameters"></param>
            <param name="arguments"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.OperationMethod">
            <summary>
            Operation calculation method
            </summary>
            <param name="operands"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.GenericUnaryOperation`2">
            <summary>
            Generic Unary operation delegate
            </summary>
            <typeparam name="OperandType"></typeparam>
            <typeparam name="ReturnType"></typeparam>
            <param name="operand"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.GenericBinaryOperation`3">
            <summary>
            Generic Binary operation delegate
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
            <typeparam name="ReturnType"></typeparam>
            <param name="operand1"></param>
            <param name="operand2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Operators.UnaryBooleanOperator">
            <summary>
            Unary operator with Boolean return type.
            </summary>
        </member>
        <member name="T:Analytics.Operators.BinaryBooleanOperator">
            <summary>
            Binary operator with Boolean return type.
            </summary>
        </member>
        <member name="T:Analytics.Operators.UnarySpecialOperator">
            <summary>
            Unary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Operators.BinarySpecialOperator">
            <summary>
            Binary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUnarySpecialOperator`2">
            <summary>
            Abstract Generic Unary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericBinarySpecialOperator`3">
            <summary>
            Abstract Generic Binary Special operator.
            (just for class hierarchy)
            </summary>
        </member>
        <member name="T:Analytics.Operators.NotOperator">
            <summary>
            Base abstract class for Logical Not operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.AndOperator">
            <summary>
            Base abstract class for Logical And operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.OrOperator">
            <summary>
            Base abstract class for Logical Or operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.IdenticallyOperator">
            <summary>
            Base abstract class for Relational Identity operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.ApproximatelyOperator">
            <summary>
            Base abstract class for Relational Approximately operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.NotequalOperator">
            <summary>
            Base abstract class for Relational Notequal operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GreaterOperator">
            <summary>
            Base abstract class for Relational Greater operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LessOperator">
            <summary>
            Base abstract class for Relational Less operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GreaterorequalOperator">
            <summary>
            Base abstract class for Relational Greater or Equal operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LessorequalOperator">
            <summary>
            Base abstract class for Relational Less or Equal operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.AddOperator">
            <summary>
            Base abstract class for Add (+) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.SubtractOperator">
            <summary>
            Base abstract class for Subtract (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.MultiplyOperator">
            <summary>
            Base abstract class for Multiply (*) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DivideOperator">
            <summary>
            Base abstract class for Divide (/) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DotOperator">
            <summary>
            Base abstract class for Dot (dot) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.PowerOperator">
            <summary>
            Base abstract class for Power (^) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.MinusOperator">
            <summary>
            Base abstract class for Unary Minus (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.SquareRootOperator">
            <summary>
            Base abstract class for Square Root operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.TildeOperator">
            <summary>
            Base abstract class for Tilde (~) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.FactorialOperator">
            <summary>
            Base abstract class for Factorial (!) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.ApostropheOperator">
            <summary>
            Base abstract class for Apostrophe (') operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.QuestionOperator">
            <summary>
            Base abstract class for Question (?) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.NumberOperator">
            <summary>
            Base abstract class for Number (#) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.AbsoluteOperator">
            <summary>
            Base abstract class for Absolute (||) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DerivativeOperator">
            <summary>
            Base abstract class for Derivative operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.IntegralOperator">
            <summary>
            Base abstract class for Integral operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DeltaOperator">
            <summary>
            Base abstract class for Delta operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.SumOperator">
            <summary>
            Base abstract class for Sum operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.ProductOperator">
            <summary>
            Base abstract class for Product operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LeftarrowOperator">
            <summary>
            Base abstract class for Left Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.RightarrowOperator">
            <summary>
            Base abstract class for Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.UparrowOperator">
            <summary>
            Base abstract class for Up Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.DownarrowOperator">
            <summary>
            Base abstract class for Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.LeftrightarrowOperator">
            <summary>
            Base abstract class for Left-Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.UpdownarrowOperator">
            <summary>
            Base abstract class for Up-Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericItenticallyOperator`2">
            <summary>
            Base Generic class for Relational Identity operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericApproximatelyOperator`2">
            <summary>
            Base Generic class for Relational Approximately operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericNotequalOperator`2">
            <summary>
            Base Generic class for Relational Notequal operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericGreaterOperator`2">
            <summary>
            Base Generic class for Relational Greater operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericLessOperator`2">
            <summary>
            Base Generic class for Relational Less operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericGreateroreequalOperator`2">
            <summary>
            Base Generic class for Relational Greater or Equal operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericLessoreequalOperator`2">
            <summary>
            Base Generic class for Relational Less or Equal operators
            </summary>
            <typeparam name="Operand1Type"></typeparam>
            <typeparam name="Operand2Type"></typeparam>
        </member>
        <member name="T:Analytics.Operators.GenericAddOperator`3">
            <summary>
            Base Generic class for Add (+) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericSubtractOperator`3">
            <summary>
            Base Generic class for Subtract (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericMultiplyOperator`3">
            <summary>
            Base Generic class for Multiply (*) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDivideOperator`3">
            <summary>
            Base Generic class for Divide (/) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDotOperator`3">
            <summary>
            Base Generic class for Dot (dot) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericPowerOperator`3">
            <summary>
            Base Generic class for Power (^) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericMinusOperator`2">
            <summary>
            Base Generic class for Unary Minus (-) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericSquareRootOperator`2">
            <summary>
            Base Generic class for Square Root operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericTildeOperator`2">
            <summary>
            Base Generic class for Tilde (~) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericFactorialOperator`2">
            <summary>
            Base Generic class for Factorial (!) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericApostropheOperator`2">
            <summary>
            Base Generic class for Apostrophe (') operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericAbsoluteOperator`2">
            <summary>
            Base Generic class for Absolute (||) operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDerivativeOperator`2">
            <summary>
            Base abstract generic class for Derivative operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericIntegralOperator`2">
            <summary>
            Base abstract generic class for Integral operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDeltaOperator`2">
            <summary>
            Base abstract generic class for Delta operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericSumOperator`2">
            <summary>
            Base abstract generic class for Sum operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericProductOperator`2">
            <summary>
            Base abstract generic class for Product operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericLeftarrowOperator`3">
            <summary>
            Base abstract generic class for Left Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericRightarrowOperator`3">
            <summary>
            Base abstract generic class for Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUparrowOperator`3">
            <summary>
            Base abstract generic class for Up Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericDownarrowOperator`3">
            <summary>
            Base abstract generic class for Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericLeftrightarrowOperator`3">
            <summary>
            Base abstract generic class for Left-Right Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericUpdownarrowOperator`3">
            <summary>
            Base abstract generic class for Up-Down Arrow operators
            </summary>
        </member>
        <member name="T:Analytics.Operators.RuntimeUnaryOperator">
            <summary>
            Unary operator created at run-time.
            Based on metainformation of a static method
            and intended to represent an overloaded operator.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeUnaryOperator.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeUnaryOperator.#ctor(Analytics.OperatorType,System.Reflection.MethodInfo)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Operators.RuntimeBinaryOperator">
            <summary>
            Binary operator created at run-time.
            Based on metainformation of a static method
            and intended to represent an overloaded operator.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeBinaryOperator.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.RuntimeBinaryOperator.#ctor(Analytics.OperatorType,System.Reflection.MethodInfo)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericRuntimeUnaryOperator`2">
            <summary>
            Generic Unary operator created at run-time.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            TODO: How to use?
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeUnaryOperator`2.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeUnaryOperator`2.#ctor(Analytics.OperatorType,Analytics.GenericUnaryOperation{`0,`1})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Operators.GenericRuntimeBinaryOperator`3">
            <summary>
            Generic Binary operator created at run-time.
            NOTE: Not SEALED to be not registered automatically (it is a hook).
            TODO: How to use?
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeBinaryOperator`3.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Analytics.Operators.GenericRuntimeBinaryOperator`3.#ctor(Analytics.OperatorType,Analytics.GenericBinaryOperation{`0,`1,`2})">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.BaseExpression">
            <summary>
            Base abstract class for all Expressions.
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.BaseExpression.value">
            <summary>
            Primary String value from wich the expression is created
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetValue">
            <summary>
            Gets value if defined, or reconstructed if the primary is undefined
            (for internal use only - to string, Print ...)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.ConstantEvaluate">
            <summary>
            Partially evaluates constant part of expression.
            No evaluation implemented by default, must be overriden in specific expression classes.
            </summary>
            <returns>True, if some evaluation done.</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Reconstruct">
            <summary>
            Reconstructs the expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.IsConstant">
            <summary>
            Expression is constant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            (not abstract to define default behaviour - exception)
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Simplify">
            <summary>
            Simplifies the expression.
            (does nothing by default, must be overriden in specific classes)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.CreateBinaryExpression(System.String,Analytics.BinaryOperationType,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Creates binary expression of the specified type.
            </summary>
            <param name="x"></param>
            <param name="bt"></param>
            <param name="operands"></param>
            <param name="operators"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Build(System.String)">
            <summary>
            Builds an expression from the string value (recursive).
            </summary>
            <param name="value">String value</param>
            <returns>Built expression, null or throws an exception</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.BuildList(System.Collections.Generic.List{System.String})">
            <summary>
            Builds a list of expressions.
            </summary>
            <param name="values">String values (can be null)</param>
            <returns>Built expressions (can return null for null value list)</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.MergeDegenerated(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Changes degenerated unary and binary expressions by their Operands.
            </summary>
            <param name="expressions"></param>
            <returns>The number of changes made</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.SimplifyList(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Boolean)">
            <summary>
            Simplifies all items in the list.
            </summary>
            <param name="expressions"></param>
            <param name="mergeDegenerated">Merge degenerated binary expressions after simplification</param>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetPrimaries(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Gets the list of expression primary values
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.GetReconstructed(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Gets the list of reconstructed expressions
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.IsDependant(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.String)">
            <summary>
            Checks if the list of expressions depend on a variable.
            </summary>
            <param name="expressions">Expressions</param>
            <param name="vName">Variable name</param>
            <returns>True, if at least one depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.Derivatives(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates derivatives of the expression list.
            </summary>
            <param name="expressions">Expressions (can be null)</param>
            <param name="context">Derivative context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivatives of the expressions or null.</returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.AreConstant(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Checks if all the expressions are constant.
            </summary>
            <param name="expressions"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.RemoveSame(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Removes the same (exactly) expressions from the lists
            (one by one from each list).
            </summary>
            <param name="expressions1"></param>
            <param name="expressions2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BaseExpression.FindCount(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},Analytics.Syntactic.BaseExpression)">
            <summary>
            Finds count of the same expresions in the list.
            </summary>
            <param name="expressions"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.BaseExpression.PrimaryValue">
            <summary>
            Primary value
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.SimpleExpression">
            <summary>
            Base abstract class for all Simple Expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SimpleExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="T:Analytics.Syntactic.StructuredExpression">
            <summary>
            Base abstract class for all Structured Expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the contained expressions.
            </summary>
            <param name="vName"></param>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aValue"></param>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.Replace(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces contained variable by given expression.
            </summary>
            <param name="vName"></param>
            <param name="expr"></param>
            <returns>Number of replaced occurencies</returns>
        </member>
        <member name="M:Analytics.Syntactic.StructuredExpression.ReplaceInList(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces contained variable in all expressions of the list by given expression.
            Variable expression in the list are replaced directly.
            </summary>
            <param name="expressions"></param>
            <param name="vName"></param>
            <param name="expr"></param>
            <returns>Total number of replacements.</returns>
        </member>
        <member name="T:Analytics.Syntactic.LiteralExpression">
            <summary>
            Literal 
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aValue">This is the value of the literal</param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Simplify">
            <summary>
            Simplifies constant expression - extracts known constants.
            Now only constants detected by parser are simplified (real and complex).
            We cannot detect Pi/2 value, because we cannot change the type
            of Expression from Literal to Binary operations.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsConstant">
            <summary>
            Literal is always constant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>False (literal is constant)</returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsZero(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal zero.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsUnit(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal unit.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsNegation(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal NEGATED unit.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsEuler(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if an expression is literal Euler e number.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsPi(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if a literal expression is Pi number.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsNaN(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if a literal expression is NaN.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsInfinity(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if a literal expression is Infinity.
            WARNING: POSITIVE infinity only.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsFalse(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if the expression is literal False
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsTrue(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks if the expression is literal True
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LiteralExpression.IsUnnamed(Analytics.Syntactic.BaseExpression)">
            <summary>
            Checks, if the expression is unnamend (nonstandard) literal.
            Supported - real and complex literals.
            </summary>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Value">
            <summary>
            Value of the literal
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Zero">
            <summary>
            Zero Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsZero).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Unit">
            <summary>
            Unit Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsUnit).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Euler">
            <summary>
            Euler number e Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsEuler).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Pi">
            <summary>
            Pi number Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsPi).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.NaN">
            <summary>
            NaN Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsNaN).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.Infinity">
            <summary>
            Infinity Literal.
            Use to return as calculation result,
            DO NOT use to compare literals (use IsInfinity).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.False">
            <summary>
            False literal.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.LiteralExpression.True">
            <summary>
            True literal.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.VariableExpression">
            <summary>
            Variable
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="aValue">Primary value is the name of the variable</param>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.IsConstant">
            <summary>
            Variable is never constant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if the names are the same.</returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.VariableExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.VariableExpression.Name">
            <summary>
            Name of the variable
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.IndexingExpression">
            <summary>
            Indexed data item
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.IndexingExpression.name">
            <summary>
            Array variable name
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.IndexingExpression.indexes">
            <summary>
            Array index expressions
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the indexes expressions.
            </summary>
            <param name="vName"></param>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.#ctor(System.String,System.String,System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
            <param name="aValue">The primary string from wich the expression is built</param>
            <param name="aName">The name of the array</param>
            <param name="theIndexes">The indexes of the array (cannot be null)</param>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.IsConstant">
            <summary>
            Indexed (variable) is never constant.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.Simplify">
            <summary>
            Simplifies all index expressions.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.IndexingExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.IndexingExpression.Name">
            <summary>
            Array variable name
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.IndexingExpression.Indexes">
            <summary>
            Array index expressions
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.IndexingExpression.IndexCount">
            <summary>
            Index Count of the Array Item
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.FunctionExpression">
            <summary>
            Function
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.FunctionExpression.name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.FunctionExpression.parameters">
            <summary>
            Parameter expressions
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.FunctionExpression.arguments">
            <summary>
            Argument expressions
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the parameter and argument expressions.
            </summary>
            <param name="vName"></param>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.#ctor(System.String,System.String,System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
            <param name="aValue">Primary string</param>
            <param name="aName">Name of the function</param>
            <param name="theParameters">Parameter expressions (can be null)</param>
            <param name="theArguments">Argument expressions (can be null)</param>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.IsConstant">
            <summary>
            Function expression is constant if all arguments and parameters are.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Simplify">
            <summary>
            Simplifies all parameters and arguments
            (standard functions properties are not taket into account)
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Functional Expression Derivative
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateSimple(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates simple function expression with one argument and given name.
            </summary>
            <param name="func"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateParametric(System.String,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates parametric function expression with one parameter, one argument and given name.
            </summary>
            <param name="func"></param>
            <param name="parameter"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.FunctionExpression.CreateBiparametric(System.String,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Creates biparametric function expression with two parameters, one argument and given name.
            </summary>
            <param name="func"></param>
            <param name="parameter1"></param>
            <param name="parameter2"></param>
            <param name="argument"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.Name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.ParameterCount">
            <summary>
            Parameter count
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.ArgumentCount">
            <summary>
            Argument count
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.Parameters">
            <summary>
            Function parameters
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.FunctionExpression.Arguments">
            <summary>
            Function arguments
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.UnaryOperatorExpression">
            <summary>
            Unary operator expression: operator + operand
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.UnaryOperatorExpression.sign">
            <summary>
            Operator sign
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.UnaryOperatorExpression.position">
            <summary>
            Operator position
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.UnaryOperatorExpression.operand">
            <summary>
            Operand
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Degenerate">
            <summary>
            Degenerates the expression
            (assigns sign = "")
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the operand expression.
            </summary>
            <param name="vName"></param>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.#ctor(System.String,System.String,Analytics.OperatorPosition,Analytics.Syntactic.BaseExpression)">
            <summary>
            Constructor
            </summary>
            <param name="aValue"></param>
            <param name="aSign"></param>
            <param name="pos"></param>
            <param name="anOperand"></param>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Reconstruct">
            <summary>
            Reconstructed string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.IsConstant">
            <summary>
            Unary operation is constant if the operand is.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates Expression Derivative
            (WARNING: NOT defined for some operators and can throw the exception)
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName">Variable Name</param>
            <returns>Derivative expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Negate(Analytics.Syntactic.BaseExpression)">
            <summary>
            Negates an expression.
            WARNING: Uses equality -(-x) = x
            </summary>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Simplify">
            <summary>
            Simplifies operand then uses the following rules:
            1. -0 = 0
            2. 0! = 1, 1!=1
            3. True = False, False = true
            4. Square root of 0, 1, Infinity or NaN is the operand value
            TODO: use other rules.
            WARNING: the expression is DEGENERATED after simplification.
            Further simplification cannot be done because we need to know
            operator semantic meaning (it depends on the operand type which
            is not known at this stage).
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.UnaryOperatorExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Sign">
            <summary>
            Operator sign
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Operator">
            <summary>
            Gets operator type (based on Sign).
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Position">
            <summary>
            Position
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Operand">
            <summary>
            Operand
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.Precedence">
            <summary>
            Precedence of the operator (based on Operator)
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.UnaryOperatorExpression.IsDegenerated">
            <summary>
            Checks if the Unary operator expression is degenerated
            (contains no operation but operand only).
            It may happen after simplification procedure.
            If the operation is degenerated its VALUE is just
            the OPERAND's value.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.BinaryOperationsExpression">
            <summary>
            A sequence of Binary Operations Expression
            operand1 x operand2 x ... x operandN
            The operator count must equal operand count - 1.
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.BinaryOperationsExpression.operators">
            <summary>
            Operator signs
            </summary>
        </member>
        <member name="F:Analytics.Syntactic.BinaryOperationsExpression.operands">
            <summary>
            Operand expressions
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.ReplaceInside(System.String,Analytics.Syntactic.BaseExpression)">
            <summary>
            Replaces variable by given expression inside the operand expressions.
            </summary>
            <param name="vName"></param>
            <param name="expr"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.GetPrecedence">
            <summary>
            Precedence of the operator sequence
            (because all operators must have equal precedence)
            Default implementation is based on the first operator,
            can be overriden in descendant classes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.GetBinaryType">
            <summary>
            Returns binary operation type
            (default implementation based on the first operator in 
            the expression, can be overriden in descendant classes).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.SimplifyOperands">
            <summary>
            Simplifies all operands
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.RemoveOperationLeft(System.Int32)">
            <summary>
            Removes operation with its LEFT operand.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.RemoveOperationRight(System.Int32)">
            <summary>
            Removes operation with its RIGHT operand.
            </summary>
            <param name="operation"></param>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.ClearOperations">
            <summary>
            Just removes all operators and operands.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.Reconstruct">
            <summary>
            Reconstructed expression
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.IsConstant">
            <summary>
            Binary operation sequence is constant if all the operands are.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.DependsOn(System.String)">
            <summary>
            The expression depends on a variable.
            </summary>
            <param name="vName">Variable Name</param>
            <returns>True, if depends</returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.Simplify">
            <summary>
            Just simplifies operands.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.ToString">
            <summary>
            To string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.Print(System.Int32)">
            <summary>
            Print string (just for testing)
            </summary>
            <param name="level"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.BinaryOperationsExpression.MakeBinary(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},System.String)">
            <summary>
            Makes binary expression with the same operator (sign).
            </summary>
            <param name="expressions"></param>
            <param name="sign"></param>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.OperationCount">
            <summary>
            Operation count
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.IsDegenerated">
            <summary>
            Checks if the binary operations expression is degenerated
            (contains one operand and no operation).
            If true, it can be replaced by Operands[0] expression.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.Precedence">
            <summary>
            Precedence of the operator sequence
            (because all operators must have equal precedence)
            Default implementation is based on the first operator,
            can be overriden in descendant classes.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.BinaryType">
            <summary>
            Type of binary expression.
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.Operators">
            <summary>
            Operator signs
            </summary>
        </member>
        <member name="P:Analytics.Syntactic.BinaryOperationsExpression.Operands">
            <summary>
            Operand expressions
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.LogicalExpression">
            <summary>
            Logical binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.GetPrecedence">
            <summary>
            Precedence of the logical operator sequence
            (based on the 'and' operator precedence).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Logical
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Logical expression derivative - defined for constant expression only.
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.LogicalExpression.Simplify">
            <summary>
            Simplifies logical expression (operands only).
            TODO: simplify using standard logical identities
                  (CAN WE DO THIS - if the logical operators are
                   overloaded for some type we cannot use standard
                   logical rules for them)
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.RelationalExpression">
            <summary>
            Relational binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.GetPrecedence">
            <summary>
            Precedence of the Relational operator sequence
            (based on the '>' operator precedence).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Relational
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Relational expression derivative - defined for constant expression only.
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.RelationalExpression.Simplify">
            <summary>
            Simplifies logical expression (operands only).
            TODO: simplify using standard logical identities.
            </summary>
        </member>
        <member name="T:Analytics.Syntactic.SumExpression">
            <summary>
            Sum binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.ConstantEvaluate">
            <summary>
            Evaluation algorith does not work because there is NO registered
            operators to make operations with literals.
            </summary>
            <returns>False</returns>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.GetPrecedence">
            <summary>
            Precedence of the SUM operator sequence
            (based on the '+' operator precedence).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Sum
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Sum expression derivative.
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.Simplify">
            <summary>
            Simplifies sum expression removing all zero operands.
            After this makes constant part of expression evaluation.
            WARNING: expression can be degenerated after simplification.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.MakeSum(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes sum of two operands x1+x2.
            Simplifies result using equalities: 
            0+x2 = x2
            x1+0 = x1
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.SumExpression.MakeDifference(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes difference of two operands x1-x2.
            Simplifies result using equalities: 
            x1-0 = x1
            0-x2 =-x2
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Syntactic.ProductExpression">
            <summary>
            Product binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.GetPrecedence">
            <summary>
            Precedence of the PRODUCT operator sequence
            (based on the '*' operator precedence).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Product
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.Decompose(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression}@,System.Collections.Generic.List{Analytics.Syntactic.BaseExpression}@)">
            <summary>
            Extracts from product expression x1*x2/x3*x4*x5/x6...
            numerator (x1,x2,x4,x5...) and denominator (x3,x6...) expressions.
            </summary>
            <param name="numerator"></param>
            <param name="denominator"></param>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.ToFraction">
            <summary>
            Converts product expression x1*x2/x3*x4*x5/x6...  
            to equivalent 'fraction' expression n/d, where n=(x1,x2,x4,x5...) d=(x3,x6...)
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Product expression derivative.
            (decomposes the expression into numerator and denominator expressions,
            if there is no denominator - calculates 'pure product' derivative,
            else - calculates fraction derivative).
            </summary>
            <param name="context">Derivative Context</param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.Simplify">
            <summary>
            Simplifies the product expression using the following rules:
            1. Removing all unit items.
            2. If there are more 0 in numerator than in denominator then = 0.
            3. Finds the same expressions in the numerator and in the denominator and redice them.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.ProductDerivative(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression},Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates product derivative.
            (x1*x2*x3*...*xn)' = x1'*(x2*x3*...)+x2'*(x1*x3*...)+...
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.DivisionDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates division expression derivative (n/d)'.
            (n/d)' = (n'd-d'n)/d^2
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.MakeProduct(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes product of two operands x1*x2.
            Simplifies result using equalities: 
            NaN*x2 or x1*NaN = NaN
            0*x2 = 0, x2 is not Infinity
            x1*0 = 0, x1 is not Infinity
            1*x2 = x2
            x1*1 = x1
            -1*x2 = -x2
            x1*(-1) = -x1
            WARNING: positive infinity only.
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.MakeDivision(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes division of two operands x1/x2.
            Simplifies result using equalities: 
            NaN/x2 or x1/NaN = NaN
            x1/1 = x1
            0/x2 = 0, x2 is not zero
            x1/(-1) = -x1
            </summary>
            <param name="x1"></param>
            <param name="x2"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ProductExpression.SimplifyProduct(System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Makes simplified expression from a sequence of products x1*x2*...*xn.
            (sequentially applies MakeProduct method to multipliers).
            </summary>
            <param name="multipliers"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Syntactic.PowerExpression">
            <summary>
            Power binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.GetPrecedence">
            <summary>
            Precedence of the POWER operator sequence
            (based on the '^' operator precedence).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Power
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.ToHierarchical">
            <summary>
            Makes equivalent hierarchical power expression from the sequence of power operations.
            f1(x)^f2(x)^..^fn(x) = ((f1(x)^f2(x))^f3(x))^..)^fn(x).
            NOTE: left assosiativity assumed!
            WARNING: Works only for operand count >= 2.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Power (sequence) derivative (f1(x)^f2(x)^..^fn(x))'.
            Recursive implementation. For two operands direct formula (f(x)^g(x))' used,
            for more operands the sequence is converted into equivalent hierarchical power expression.
            </summary>
            <param name="context"></param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.Simplify">
            <summary>
            Simplifies power expression.
            Uses the following equalities:
            1. f1(x)^f2(x)^...^0^...^fn(x) = 1
            (if there is a 0 power - the result is 1 because when the 0 power applied
             all before it becomes 1 and see 2)
            2. (1)^f1(x)^f2(x)^...^fn(x) = 1 
               (if the first operand is unit - result is always unit)
            3. f1(x)^1^f2(x)^f3(x)^1^f4(x)^...=f1(x)^f2(x)^f3(x)^f4(x)^...
               (all unit powers can be just removed)
            4. 0^f1(x)^f2(x)... - MUST NOT be simplified to 0, even if there is no zero powers.
                                  The result value depends on the function values and can be
                                  defined after calculation only.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.PowerDerivative(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression,Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Calculates power derivative (f(x)^g(x))'.
            There are three main cases:
            1. f=const. (f^g(x))' = ln(f)*f^g(x)*g'(x).
            2. g=const (f(x)^g)' = g*f(x)^(g-1)*f'(x), g is not 0.
            3. (f(x)^g(x))' = ln(f(x))*f(x)^g(x)*g'(x)+g(x)*f(x)^(g(x)-1)*f'(x)
            (=const means that it does not depend on variable x)
            </summary>
            <param name="f">Value f(x)</param>
            <param name="g">Power g(x)</param>
            <param name="context"></param>
            <param name="vName"></param>
            <returns>Derivative Expression</returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.MakePower(Analytics.Syntactic.BaseExpression,Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes power expression x^y.
            NOTE: uses some simplifications x^1 = x, x^0 = 1.
            WARNING: now x^0 is always 1, no matter if x is Infinite!
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.MakeSquare(Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes square expression of the value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.PowerExpression.MakeSquareRoot(Analytics.Syntactic.BaseExpression)">
            <summary>
            Makes square root expression of the value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Analytics.Syntactic.ArrowExpression">
            <summary>
            Arrow binary expression.
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.GetPrecedence">
            <summary>
            Precedence of the Arrow operator sequence
            (based on the 'left arrow' operator precedence).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.GetBinaryType">
            <summary>
            Returns binary operation type - Arrow
            </summary>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.#ctor(System.String,System.Collections.Generic.List{System.String},System.Collections.Generic.List{Analytics.Syntactic.BaseExpression})">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.Derivative(Analytics.Derivatives.DerivativeContext,System.String)">
            <summary>
            Arrow (sequence) derivative is defined for constant expression only.
            </summary>
            <param name="context"></param>
            <param name="vName"></param>
            <returns></returns>
        </member>
        <member name="M:Analytics.Syntactic.ArrowExpression.Simplify">
            <summary>
            Simplifies operands only.
            There are no other simplification rules because
            the sense of the operators can be different.
            </summary>
        </member>
        <member name="T:Analytics.OperatorType">
            <summary>
            All defined operators.
            - new operators cannot be defined;
            - the precedence of operators cannot be redefined;
            - the number of operator's operands cannot be redefined;
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.And">
            <summary>
            logical and (binary)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Or">
            <summary>
            logical or  (binary)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Identically">
            <summary>
            equality (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Approximately">
            <summary>
            approximate equality (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Notequal">
            <summary>
            notequality (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Greater">
            <summary>
            greater (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Less">
            <summary>
            less (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Greaterorequal">
            <summary>
            greater or equal (binary, relational)    
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Lessorequal">
            <summary>
            less or equal (binary, relational)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Add">
            <summary>
            binary +
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Subtract">
            <summary>
            binary -
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Multiply">
            <summary>
            binary *
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Divide">
            <summary>
            binary /
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Dot">
            <summary>
            binary dot 
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Power">
            <summary>
            power ^ (binary)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Leftarrow">
            <summary>
            Left arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Rightarrow">
            <summary>
            Right arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Uparrow">
            <summary>
            Up arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Downarrow">
            <summary>
            Down arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Leftrightarrow">
            <summary>
            Left-Right arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Updownarrow">
            <summary>
            Up-Down arrow
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Not">
            <summary>
            logical not (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Question">
            <summary>
            question (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Number">
            <summary>
            Number (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Minus">
            <summary>
            minus - (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Tilde">
            <summary>
            tilde ~ (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.SquareRoot">
            <summary>
            Square Root (unary prefix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Derivative">
            <summary>
            Derivative
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Integral">
            <summary>
            Integral
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Delta">
            <summary>
            Delta
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Sum">
            <summary>
            Summ
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Product">
            <summary>
            Product
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Factorial">
            <summary>
            factorial ! (unary postfix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Apostrophe">
            <summary>
            apostrophe ' (unary postfix)
            </summary>
        </member>
        <member name="F:Analytics.OperatorType.Absolute">
            <summary>
            // absolute || (unary outfix)
            TODO: WARNING - this operator is not totally realized.
                  It makes some difficulties. Because the opening
                  and closing symbols are the same, it is hard to
                  distinguish them and parse expressions corectly.
            </summary>
        </member>
        <member name="T:Analytics.OperatorArity">
            <summary>
            Operator arity
            </summary>
        </member>
        <member name="F:Analytics.OperatorArity.Nullary">
            <summary>
            Undefined arity
            </summary>
        </member>
        <member name="F:Analytics.OperatorArity.Unary">
            <summary>
            Unary
            </summary>
        </member>
        <member name="F:Analytics.OperatorArity.Binary">
            <summary>
            Binary
            </summary>
        </member>
        <member name="T:Analytics.OperatorPosition">
            <summary>
            Operator position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Unknown">
            <summary>
            Unknown position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Prefix">
            <summary>
            Prefix position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Postfix">
            <summary>
            Postfix position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Infix">
            <summary>
            Infix position
            </summary>
        </member>
        <member name="F:Analytics.OperatorPosition.Outfix">
            <summary>
            Outfix position
            </summary>
        </member>
        <member name="T:Analytics.OperatorAssociativity">
            <summary>
            Operator associativity.
            Determines the order in which the operators are applied.
            From left to right (+ operator) or from right to left (assignment operator).
            </summary>
        </member>
        <member name="F:Analytics.OperatorAssociativity.Unknown">
            <summary>
            Undefined
            </summary>
        </member>
        <member name="F:Analytics.OperatorAssociativity.Left">
            <summary>
            Left-associative
            </summary>
        </member>
        <member name="F:Analytics.OperatorAssociativity.Right">
            <summary>
            Right-associative
            </summary>
        </member>
        <member name="T:Analytics.BinaryOperationType">
            <summary>
            Binary Operation type defines the type
            of sequence of binary operations of the same precedence
            (example 'x-y+2' - sum, 'x/y*z' - product).
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Logical">
            <summary>
            Logical operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Relational">
            <summary>
            Relational operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Sum">
            <summary>
            Summ operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Product">
            <summary>
            Product operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Power">
            <summary>
            Power operations
            </summary>
        </member>
        <member name="F:Analytics.BinaryOperationType.Arrow">
            <summary>
            Arrow operation
            </summary>
        </member>
        <member name="T:Analytics.LiteralEvaluator">
            <summary>
            Class to evaluate literal expressions.
            </summary>
        </member>
        <member name="M:Analytics.LiteralEvaluator.#ctor(Analytics.LiteralIs,Analytics.LiteralEvaluate)">
            <summary>
            Constructor
            </summary>
            <param name="li"></param>
            <param name="le"></param>
        </member>
        <member name="P:Analytics.LiteralEvaluator.Is">
            <summary>
            Is function
            </summary>
        </member>
        <member name="P:Analytics.LiteralEvaluator.Evaluate">
            <summary>
            Evaluate function
            </summary>
        </member>
    </members>
</doc>
